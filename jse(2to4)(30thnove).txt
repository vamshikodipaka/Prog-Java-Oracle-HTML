Language: 	
	Language is a communication channel between two end points(users).
	Many of the people uses the languages like hindi,telugu,tamil,english for communication.
	If we want to interact with the machine, then we need one special language that is Programming Language.


Programming Lanuage:
	A language, which is understand by the machine to process is called Programming language.

Aspects of ProgrammingLanuage:
	*Stroing the data
	* Accessing the data
	* Processing the data
	* delete the data
	* update the data.

We have threee types of programminglanguage.
	a.Binary language or Machine language.
	b.Assembly language
	c. Highlevel language.

BinaryLanguage: 
	This is first and machine level language.
 	This is only understand by machine.
	Machine can under the data only in the form of
zero and one's.
	Each and every character first converted into ascii/unicode values later it is converted into zero and one's.
	Developing the program under binary language is very difficult and time consuming.
	The main drawback of binarylanguage is platform dependency.
	
platform: the combination of software and hardware, it provides environment, to execute the programs.	 

Executing the programs means install software, update softwares. typing some thing in notepad.

platform dependency:	
	If we are developing and compile the program under one operating system, the same program is not executing under different operating system is called platform dependency.

Assembly language:
	This is low level language, it is used to avoid drawbacks of binary language. This language can avoids hard coding, but unable to avoid platform dependency.
This language internally uses MNEMONICS(ADD,SUB,MUL,DIV)  for developing the program.

Highlevel language:
	These language very user friendly language to easy to develop and easy to understand.
	We have different languages under highlevel. Like C,C++,.net,java,cobol,pascal and etc......

java is the language to avoid the problems of platform dependency.


With the  c,c++ we cannot develop internet support application.
With the help of java we can develop internet support application, the reason java is an pure platform independent software.

Software: 
	It is a development tool, which is used to convert our imaginary things to real world existing things, by writing set of programs.	
We have three types of softwares.
System Software: the software, which is used to to develop
hardware functionalaties.
	ex: c, embdedsystems.
Application software: All the back end or database software are comes under application software.
Internet software: To develop internet applications
	ex: java, .net.

Java is comming in the form of three flavours.
	java standard edition
	java enterprise edition
	java mobile or micro edition

java software comes with two separate components.
	a.JDK
	b.JRE

java buzzwords: 
or java features:

	simple
	platform independency
	high performance
	security
	Architectural neutral
	portable
	robust
	mulithreading
	distributed
	dynamic
	oops

simple:
	java is an simple language, due to the following reasons.
	1.avoiding pointers
	2.garbage collection.
	3.provides huge predefine code.(packages)
If we are  using pointers in java we are unable provide security to our code, our java code may effected by virus and hacking programs.

garbage collection:
	cleanup the unused memory in java is called garbage collection or finalization.
if we go for other language, programer should be write the code for both memory allocation and deallocation.
But in java, programmer is not writing code for deallocating the memory, jvm itself communicating with garbage collector to cleanup the memory.

java provide a huge predefine code or lowlevel logic.

with the help of this code, we can develop our project with in the less time and very easily.
	rt.jar
	
	packages

	class/interface/enum/subpackage
	
	methods
	
	code/logic


Platform Independency:
	Developing an application,compile the same application in one operating stystem, if we execute the same applicaiton in all operating systems is called platform independency.	
	
SourceCode: The code which is writing in any language(c,c++,.net,java) that code is called sourcecode.

Machine code: 
or
Binary code: 	The code which is understand by the machine is called binary code or machine code.

Source code is not understand by the machine.So we need translate source code to machine code. To translate the source to machine code, java provides two translators.
	1.compiler
	2.jvm

Translator: It is program which is used to convert from one type of code to another type of code.

Every java name must be ended with .java file, once we save the file, then that file available in harddisk.

with in the .java file we can write multiple classes.

If we want to interact with the compiler we need one predefine development tool that is "javac". 


javac always followed by filename.java
	ex: javac FirstDemo.java
when ever we written the above syntax in command prompt automatically compiler will come in to the picture, it will interact with .java file, compiler will communicate with hard dis. 
If the file not available compiler will give file not found error.
If available .java file is loading from secondary memory to primary memory.

mean while loading compiler will check is source code properly designed under java grammer rule or not.

If not compiler will give CompileTimeError. 

If code is properly designed then compiler will convert into byte code or jvm understandable code or intermediate code, and finally that code will be placed into .class files.

As many classes we have in one .java file, those many .class files will be created by the compiler.
 Different classes  having different .class files and different byte code.
After creating the .class files, compiler will place all the .class into same directly(folder) in hard disk.

Bytecode: The code which is generated by the compiler is called bytecode. It is not understand by the programmer and machine.
	
compilation: Converting from source code to bytecode

What ever the code which is generated by compiler that is not understand by machine. so again we need to convert from byte code to machine code. For that purpose we need one more translator, that is jvm.
	
if we want to interact with jvm we need one development tool that is java.
	java command always follwed by classname
	ex: java Demo
when ever we write above syntax in command prompt then
jvm will come into the picture, and interact with .class file name, and finally loaded from secondary memory to primary memeory. If bytecode is properly orgnaized then we will get executable code, that code is executing under all operating system. Then we can say java is an platform independency language. 
But jvm is pure platform dependent component.
The reason is we have different jvm's.
What ever code which is generated by compiler that code is understand by all jvms.  Those jvm's again convert and executed in their dependent os.

execution: convering from bytecode to executable.

slogan: Write Once and Reuse Anywhere(WORA)
	Write Once and Run Anywhere


Architectural Neutral:
	Developing and compile the application under one processor, executing the same application under different processors is called Architectural neutral.

Portable:
	The combination of PI plus AN is called portable.


OOPS: OOPS provides some rules and regulation and designs which help to develop languages very easily.
We have the following OOPS principles. Those are
	1)Class
	2)Object
	3)Encapsulation
-	4)Abstraction
	5)Inheritance
	6)Polymorphisam



History of Java:
Development of java is start from Green Team(java team).
Initially java had introduced for digital devices(set-top boxes, televisions etc).
Now java is used internet programming, mobile devices, games, e-business).
James goshling, Patrik Naughton introduced in 1991 june.
Initially it was called greetalk and file extension is ".gt".
After this language renamed as OAK.
OAK is symbol of strength.
OAK is the tree name. 
It is the national tree for Germany,USA, France
In  1995 OAK renamed as Java.
No abbrevations for OAK and Java.
Java is an island of indonesia.
 (First cofee was produced).
In 1995 java introduced version like JDK Alpha and Beta.
In 1996 JDK 1.0 version released inthe market.	
JDK Alpha and Beta (1995)
JDK 1.0 (23rd Jan, 1996)
JDK 1.1 (19th Feb, 1997)
J2SE 1.2 (8th Dec, 1998)
J2SE 1.3 (8th May, 2000)
J2SE 1.4 (6th Feb, 2002)
J2SE 5.0 (30th Sep, 2004)
Java SE 6 (11th Dec, 2006)
Java SE 7 (28th July, 2011)
Java SE 8 (18th March, 2014)
Java  software relased in the market in the form of three flavours.
	Java Standard Edition
	Java Enterprise Edition
	Java Mobile/Micro Edition




With the help above flavours we can develop the following applications.
	1.Standalone/Desktop applications.
		
	2. Client-Server programming(socket programming)
	3. Database interaction applications.
	4. Webapplications.
	5. Enterprise/Distributed applications.
	6. Interoparable applications.
High Performance:
	If we go for other languages, they are using only one translator for executing the program. So those language will take more time to execute. If any application will take more time to execute that application performance will be decreased. 
	To avoiding this problem java internally uses two translators
		
	1. Interpreter.
	2. JIT Compiler

Compiler: It is an transloator, it will convert our source code to bytecode. It is check all line at a time, if ant syntax errors available first those errors will be placed into memory, after checking all the statements finally it will print all error information on the output device (console).

Whereas Interpreter will translate the code from bytecode to machine understandable code. It will check line by line. If current line valid then control goes to next line otherwise it will print error or exception message on the console.

Interpreter is very good at execute the single time execute statements.
Where as JIT compiler good at excute the looping statements.

But these two components does not have any capability to understand whether the statements are single time execute or looping statements.

In jvm, there is one special component i.e. "profiler".

This profiler will recognize the statement behaviour.

If statement is single time execution statement then those statements will give to Interpreter, if statements are looping statements then those statements are handover to JIT compiler.

In java both Interpreter and JIT compiler works combindly and execute the program within the less time, if program is execute with in the less time automatically the performance of an application will be increase.

By this reason, we can say java is an high performanced language.


Robust: Java is a Robust language due to the following reasons.
	1) Proper Memory Management.
	2) Exception Handling.
	3) Casting.

java inernally used one background program, which is used to maintain memory properly.

The background program is GarbageCollector. This GarbageCollector, will check is there any unused memory or not, if yes that memory will be cleanup, the same memory will be allocated to other data.

2) Exception Handling:
	Java is giving very great support to handle the both compiletime and runtime exceptions.
	
	When ever exception is raised, internally java uses some predefine code to generate exception message in the following manner.
	
	In the exception message it will give information about
	
	1) FileName
	2) ClassName
	3) MethodName
	4) LineNumber
	5) Description of an exception(Exception Message)

	Casting: In java both compile time and runtime the casting operation will be checked.
	In the compile time compiler will check is that casting is proper or not.
	if not compiler will give compiletime error.
	In the runtime jvm will check is that casting is proper or not
	if not  jvm will give runtime error.
	
By above three advantages, we can say java is a robust language.

Secure: 
	Java provides huge security in the following ways.

1) Avoiding the pointers.
2) Packages
3) Security Manager
4) Verifier.

	If are avoiding the pointers we can provide security, avoid virus and hacking code.
	With the help of packages we can provide security to both default and protected data.
	packages provides fully security to default data, but packages are not provide full security to protected data.
	If we are doing some modification on protected data, we can access from outside of the package also.
	Verifier will check whether the bytecode is properlly organized or not and is there any virus and hacking code or not.
	If yes verifier is provides one VerifierError.





Distributed: 
	Whatever applications developed under the java, those application services are equally distributed/sharable.
	Data is shared between all the machines in the form of object with in the same time.

Dynamic:
	with the help of java we can develop dynamic pages and animated games.

Multithreading:

	Executing the multiple threads concurentlly is calledmultithreading.
	With the help of multithreading we can excute our programs with the in the less time, then automatically we will improve the performance of an application.

	In general our java program contains two threads
	
	1) MainThread
	2) Garbage collector
	
	with the help main theread we can call methods, we can create memory.
	With the help of garbage collector we can cleaup the memory.

Object Oriented Programming System:
	
	Any language which has been developed based on object oriented programming system principles those language are called OOPL.
	ex: C++, .Net, java.

	We have the following OOPS.

1)Class
2)Object
3)Encapsulation
4)Abstraction
5)Inheritance
6)Polymorphisam

Major and Minor versions:
Every java software comes with two versions
		
1) Major Version
2) Minor version.

Major Version: If we want new features to the existed 
software, then we should gofor major version.
	ex: java 1.6
	      java 1.7
Minor version:
If we want add bug fixing code to the existed software,
 then we can realease our software as an minor version.

One java software is not suitable for all the operating 
systems. Different operating systems have its own java software.
	
Environment variables Setting:

Command prompt is comes with operating system, whereas java development tools(binary files) and libray files are comes with java software.
so our command prompt is unable to recognize the development tools.
Then programer should provide the information about binary and library files to commandprompt, with the help of environment variables.

OS by default uses environament variables to recognize software.
For java we have two types of path settings.

1) Temporary settings.
2) permanant  settings.

Temporary Settings:  What ever the setting witch we are done at one command prompt those settings are applicable to that command prompt only not applicable to other command prompt and also if we did close the command prompt automatically all the settings are gone.

syntax: set path=C:\Program Files\Java\jdk\bin;

With the help of above settings our command prompt recognize the binary files.(javac, java, javap command).

set classpath=.;C:\Program Files\java\jre\lib\rt.jar;

With the help of above settings our compiler and jvm can recognize the predefine .class files.
	Binary files used to compile and execute the program, where as Library files are used develop the userdefine program.
	
Permanent Settings:
	the settings are which are applicable for entire system, those settings are called permanent setttings.
	steps to permanent settings:

Right click on my computer-->Properties--> Advanced System Settings-->Advance--> EnvironmentVariables---->Under System variables.

	click on new button set the path.
variable name:path
variable value:C:\Program Files\Java\jdk1.6.0\bin;
	click on new button set the classpath.
variable name:classpath
variable value:.;C:\Program Files\Java\jre6\lib\rt.jar;

First java program:
class Demo{
	public static void main(java.lang.String[] ram){
		java.lang.System.out.println("hi friends");
	}
		
}

FileName: FirstDemo.java
ClassName: Demo
compilation: javac FirstDemo.java
execution: java Demo

Valid syntax:
	String[] ram;
	String  []   ram;
	String   []ram;
	String   ram[];

Invlid syntax:
	[]String ram;

Note: we can not place array symbol before datatype.

class Demo{
	static public  void main(java.lang.String[] ram){
		java.lang.System.out.println("hi friends");
	}
		
}

Note: we change places between static and public.
	we can develop empty .java file. This file can be compiled but we cannot get any .class file, the reason is there is no source. 
	we can not execute the program, the reason is there is no class name.
	we can create empty java class. we can compile but we cannot execute.
	in java 1.6 we got one error: NoSuchMechError:main

we cannot develop class with out class_name.
if we write the following code we will get  one compile time error that is identifier expected.
class {
}

every statement must be ended with semicolon, other wise we get compile time error that is ';' expected.

in java method must be have return type. If we are not writing, we will get compile time error that is invalid method declaration, return type required.

class Demo{
	static{
		System.out.println("this is static block");		
		System.exit(0);
	}
			
}
Without main method also we can compile and execute the program from java 1.0 to java 1.6. But in java 1.7 and 1.8 main method is mandaroty.

	System.exit(0) means, we are explacitly stopping the program.
class Demo{
	
	static public void main(String... ram){
		System.out.println("this is main method");	
	}		
}

(...) called varargs(Variable arguments). we can also called elipse.
Internally varargs maintain array concept only.
this feature is introduced in java 1.5.
valid syntax:
	String...ram;
	String...    ram;
	String   ...ram;
	String  ...    ram;
invalid syntax:
	String ram...;
	...String ram;
	String.   ..ram;
	String.. .ram;
	String .  .   .  ram;
class Demo{
	static public void main(String... ram){
		System.out.println("this is main method");	
	}		
}
class A{
}
class B{
}
class C{
}
With in the one .java file we can create multiple class. How many class keywords we have those many .class file will be generated by the compiler.

In the execution time, we should give classname, which have main method.
class Demo{
	
	static public void main(String... ram){
		System.out.println("this is Demo main method");	
	}		
}
class A{
	static public void main(String... ram){
		System.out.println("this is A main method");	
	}
	
}
class B{
	static public void main(String... ram){
		System.out.println("this is B main method");	
	}
}
Within the one .java file we can write multiple class and also in all the classes we can write main method also.
Which class name we are going to be give at execution time that class main method will be execute.
	javac FirstDemo.java
	java Demo
	java A
	java B
We can compile more than one .java file at a time. with the help of following syntax.
	javac *.java
	
But we cannot execute more than .class files at a time.
If given .java file is not existed, then compiler will give file not found error.
if given .class file is not existed, then jvm will provide NoClassDefFoundError: classname
FileName no need of same as className. But if the class is public type then our filename must be same as className otherwise compiler will give one compile time error i.e.
	class <class-name> is public, we should declared file name as <class-name>.java

we cannot write  more than one public class with in the one .java file
as bellow
public class Demo{
}
public class C{
}
*************
No user define method will be executed automatically in java, except main method.
If we want to execute the user define method, then we should call explacitly.
class B{
	void m1(){
		System.out.println("m1 method");
	}
	static public void main(String... ram){
		System.out.println("this is B main method");	
	}
}
By default compiler will provide java.lang package classes.
We can call main method explacitly by using below syntax.
	main(new String[0]);
If we call main method of other class then we should we bellow syntax
	
	Class_name.main(new String[0]);

class A{

	psv main(String... ram){
		System.out.println("hi");
		main(new String[0]);
	}

}
In the above program in the body of main method we did write one syntax like main method calling. This syntax will reach infine loop.
Finally JVM will provide one runtime error is 
"java.lang.StackOverfloeError".

The following are the java programming language elements(The syntax which is used to develop the program)
Those are
1)Comments.
2)Packages
3)Java Tokens
	a.Keywords.
	b.Literals.
	c.Operators.
	d.Separators.
	e.identifiers
		i.Class
			1.Methods
			2.Variables

		ii.Interface 
			1.Methods
			2.Variables

		iii.Enum
			1.Methods
			2.Variables
4)Annotations
5)Constructors
6)Blocks
7)Import statements

Identifiers:
	It is name or word or character which is used differentiate from one java element to another java elements.

class Student{
	public static void main(String... ram){

		System.out.println("hi");	
	}
}



To differentiate from one java element to another java element, then we can go for indentifier.

Identifier is a name, character, word which is differentiate one java element to another java element.

NamingConvensions in java:
1)class:
	class name must be startswith capital letter
	ex: Student
	
	If any class name having multiple words first word first letter must be capital letter, the remaining words first letter must be capital letter.

	ex: StudenPersonalDetails
	      
	we can use digits in the class name
	ex: Student1;

	we can use two special chracters with in the class 
	name.
	ex: Student_Info
	ex: Student$Details

	We can start class name with the help of '_' and 	'$' and combination also.

	ex: _ _ Student
	      $_$Bank

	We can use predefine class name as userdefine class name. But in this time we cannot get functionalaties from predefine class.

		ex: class String{
		      }
	note: Dont use predefine class names as userdefine class names.
	Dont use keywords as a class names.

Invalid Classnames:
	Class name never be start with digits.

	ex: 1Student //wrong

	class name doest have any spaces.
	ex:  Student Details//wrong
	       Student  Personal Details//wrong

	class name doesnot have any special characters except under(_) and dollar($).
	ex: Student"Info //wrong
	ex: Student=Info //wrong

	we cannot use keyword for class names.
	ex: class while{//wrong
	      }
Whatever rules we have about to classes, the same rules applicable to interfaces, enum, annotations.

keywords: Keywords must be write with in the small case.
	ex: for,if,else,private,public

	ex: For, Native, Strictfp  //wrong syntax

Variables:
	Variables always starts with small letter.
	ex: String name;
	       byte age;
	       float sal;

	Variables name having more than one word then first word first letter must be small letter, the remaing words first letter must be capital letter. The remaing rules same as class rules.
	ex: String studentName;
	      String accountHolderName;

Methods: Whatever the rules we have related to variabels, the same rules we have for methods also.
	There is a small different between variables and methods is method always ended with '(' and ')'.

Constants:
	all the final variables are comes under constants in java
	ex:  final double PI= 3.14;
	final variables or constant variable names are always in the capital letters.
	ex:  MIN_PRIORITY--->1
	       MAX_PRIORITY--->10
	       NORM_PRIORITY..>5
packages: 
	
 names must be in the small case.
	ex: java.lang	
	java.util
	java.io.
	java.net

	com.ram
	com.nit
	com.google

Literals:  A values which is assigns to variable is called literal
	ex: int a = 10 ;  //10 is an int literal
	char c = 'b' ; //b is an char literal
boolean b = false;//false--boolean literal
boolean b1 = true;//true--boolean literal
	String s = "ram";//ram-- String literal
Student s = null; // null---is also called as 				literal

double d = 23.34d; //23.34---is an doubleliteral
	
char literal--> always with in the single quote.
	we can not write more than one character with in the single quote.
	ex: 'a'  or '4'
	'abc' //wrong
boolean literal--> it is always either true or false.

String literal---> always with in the double quotes.

float literal always ended with either small 'f' or 'F'
	ex: float f1 = 23.23f;
	       float f2 = 56.61F;
ended 'f' or 'F' is mandatory.

double d = 34.45;
double d1 = 34.45d;
double d2 = 34.45D;

double literal can be followed by either 'd' or 'D'. It is not a mandatory.

By default all number in java comes under int literal.
By default all fractional numbers in java comes under double literal.

long l = 100;
long l1= 100L;
long l2 = 100l;

ended 'l' and 'L' is not mandatory.

keywords:
	keywords are predefine words or reserved words.
	These are having some functionalities through logic.
	These functionalities will help us to communicate with both compiler and jvm.
	Whenever our program executes internally keywords functionalities also executed.
	We have 50 keywrods in java among them 48 are used and 2 are unused

	false, true, null these are also predefine words but these not comes under keywords, these are comes under literals.
	boolean b = false;
	boolean b1 = true;
	String s = null;

List of keywords:

java files:
	class
	interface
	enum
datatypes:
	byte
	short
	int
	long
	float
	double
	char
	boolean
for return type:
	void.

controle statements:
	if
	else
	switch
	case
	default
Looping statements:
	for
	do
	while
Transfer the controle:
	break
	continue
	return
AccessModifer
	private
	public
	protected
Modifer:
	final	
	abstract
	synchronized
	strictfp
	volatile
	native
	transient
object related keyword:
	this
	super
	instanceof
relationship:
	extends
	implements
package:
	package
	import
Exception handling:
	try
	catch
	finally
	throw
	throws
	assert
memory allocation: 
	static 
	new
unused:
	goto
	const
Note: keywrods must be write in small case.
String is a predefine class, which is available in java.lang package. But we can use String as a datatype.

Separators:
	It is a small java element which is used to differentiate from one java code to another code(element).
	These are some of the special characters.
ex:	We have totally eight separators. 
Those are:
 “()” --> to differentiate variable to method

”{}”--> differentiate from class to method or method to method(scope).

 “[]”---> differentiate primitive to referenced

 ”.” ---> make a relation between class to method or class to variable

 ”,”--->use to separate one value to another value

 ”;”---> to separate one statement to another

 ”:”---> to separate one case to another in switch

 “<>”--->to separate normal collection object to generic

EscapeCharacters:
	These are used print the data in different locations.(style).
class EscapeCharacters{
	public static void main(String...ram){
		//System.out.println("hi\tbye");
//System.out.println("hi\nbye");
//System.out.println("hi\bbye");
//System.out.println("hi\rbye");
System.out.println("hi\'bye");
System.out.println("hi\"bye");
System.out.println("hi\fbye");
	}

}
Datatypes:
	Datatypes are prereserved words, which is used to  specify the type of literal/value.
	int a = 10;
	boolean b = false;
With help of datatype we can provide the memory  for variables.
	int a = 10;  // 4 bytes of memory.	
Datatypes allowes valid operations.
	boolean b = true;
	b = b++; //invalid syntax
Datatypes provides proper result/output.
	String s1 = "10";
	String s2 = "20";
	S.o.p(s1+s2);//1020
	int a = 10;
	int b = 20;
	S.o.p(a+b);//30

classification of datatypes:
diagram relation to classification.

q)  why java uses these many datatypes?
A) To use the memory in proper manner then java uses different datatypes.
If the value is small then we can go for small range of datatype.
If the values is big then we can go for higher range of datatype.


Ranges of datatypes:
	byte:(1 byte)---> 1* 8 = 8 bits
	byte b = 10;

	if we want to place the data in the memory, first we should convert into binary number system.(0,1). zero and one are two digits.

	  8
	2    = 256		           7
	           ---        = 128   =   2
	            2
	-ve number, + numbers 

	-128 to 128

	-128 to 0 to 127

	   7                  7
	-2      to  0 to 2  -1

	    8-1	       8-1
	-2      to 0 to 2  -1

The range of float, double is greater than the byte,short,int,long datatypes.

Casting:
	converting from one dataype variable value to another datatype variable value is called Casting.
	Casting is two types.
		1.implicit casting.
		2.explacit casting.

1.Implicit Casting: Converting lower data type value to higher datatype values is called implicit casting.
	
we can pass the values to variables within the range only we can not pass beyond the range values.
	int a = 10;
1)In the above statement compiler will check the destination variable type(int).
2)Based on the type, compiler will check range
3)Compiler is also checking the value of an variable.
4)If value is within the range then compiler will not give any error otherwise compiler will give one compiler time error. That is possible lossy convertion.
some times it will give incompatable error.




class Casting{
	public s
tatic void main(String args[]){
		System.out.println("main method");
		byte b = 127;		
		System.out.println("b: "+b);
		byte b2 = -128;		
		System.out.println("b2: "+b2);
		//byte b1 = 128;		
		//System.out.println("b1: "+b1);
		short s = 32767;
		System.out.println("s: "+s);
		short s1 = -32769;
		System.out.println("s1: "+s1);

	}
}

class Casting{
	public static void main(String... ram){
		char b8 = 'A';
		int b9 = b8;
		System.out.println(b9);
		byte b1 = 10;
		short b2 = b1;
		int b3 = b1;
		System.out.println(b3);
		float b4 = b1;
		System.out.println(b4);
		long b5 = 123L;
		float b6 = b5;
		System.out.println(b6);
		float b7 = 34.34F;//float must be ended 		//with  either 'f' or 'F'
		char b10 = 97;
		System.out.println(b10);
		for(int i=48;i<58;i++){
			System.out.print((char)i+" ");
		}
		System.out.println();
		for(int i=65;i<=90;i++){
			System.out.print((char)i+" ");
		}
		System.out.println();
		for(int i=97;i<=122;i++){
			System.out.print((char)i+" ");
		}System.out.println();
		char c = '?';
		System.out.println((int)c);
	}


}

Assigning the values to variables:
	We have 5 ways to assign the values to variables.
	
1.Assign the values directly to variable.
	int a = 111;
2. Assign the values to variable by using another variables.
	byte b = 222
	int c = b;
3. Assign the values to variables by using method return type.

     	int m1             =    m2();//calling area
	destination part    initialization part
	int m2(){//called area
		return 333;	
	}	
Note: "return" statement will forward the data from called area to calling area.
If any method calling is avialable in initialization part, then that method must be non-void method.
non-void method means, method carrying some information. That information must be compatable with destination variable datatype.
Method must be have return type. Return type also must be compatable with destination variable datatype. If any method having return type then that method must be have return statement with value. Again value must compatable with method return type.

4. Passing the value as an parameter to other method.
	void m3(String s){
	}

	calling the m3 method: m3("ram");

	void m2(boolean b){

	}

	calling the m2 method:   m2(true);
5) We can assign the value to variable with the help of expression.
int c = 10+20;//here 10+20 is an expression
	int a = 10;
	int b = 20;	
	int d  = a+b;//a+b  is an expression.

Functionalaties of compiler and jvm in the casting:
	
compiler:
	compiler checks type of an variables(both source and destination variables)
	Based on the type, compiler checks range of an variabels.(dattypes).
	If Destination variable Range greater than source variables Range then compiler will satisfy otherwise compiler will give error.
	(DVR>=SVR)
	Compiler not check any value.	

		short b = 111;
		int i = b;//valid
		DVR >= SVR
		
		byte b1 = b;//not valid
		
Jvm: jvm will check type of an variable, range of an variable, DVR >= SVR or not, finally jvm will check "value" also.

Note: if we assign the value directly to variable compiler will check type and range and value.
	byte b = 127;
	
ExplacitCasting: Converting from higher datatype value to lower datatype value.
	By default it is not possible in java.
	but we can do with the help of cast operator.	
		int b = 127;
		byte b1 = b;//invalid
		byte b2 = (byte)b;//valid
In the explacity casting, if the source value is with in the range, then jvm will place the same value assign to destination variable. otherwise jvm will place some other value.

public class ExplacitCasting {

	public static void main(String[] args) {
		byte b = 127;
		int i = b;
		
		int j = 127;
		byte b1 = (byte)j;
		System.out.println(b1);
		
		int k = 130;
		byte b2 = (byte)k;
		System.out.println(b2);
		
		int k1 = 150;
		byte b3 = (byte)k1;
		System.out.println(b3);
		
		int k2 = 300;
		byte b4 = (byte)k2;
		System.out.println(b4);
	}

}
Note: we can not convert boolean data type values to another data type.
	boolean b = false;
	int a = b;//invalid
boolean value we cannot placed into other datatype and any other datatype value cannot placed into boolean datatype.

	byte b = 100;
	boolean b1 = b;//invalid 
	
*********************
public class ExplacitCasting {
	public static void main(String[] args) {
		char c1 = 'a';
		//char c2 = 'ab';
		//we cannot write more than one character
		//with in the single quote
		char c2 = 100;
		System.out.println(c2);
		System.out.println((int)' ');
		System.out.println((int)'f');
		char c3 = '\u0061';//hexadecimal 		//number system
		System.out.println(c3);
		char c4 = 0061;//octal number system
		System.out.println(c4);
		
		//short s = c4;
		//boolean c5  = false;
		//byte b = c5;
		
		//boolean c6 = c4;
		float f = 23.34f;
		int f1 = (int)f;
		System.out.println(f1);
		
		double f2 = 435.1234567890d;
		long f3 = (long)f2;
		System.out.println(f3);
		float f4 = (float)f2;
		System.out.println(f4);
	}
}
Difference between print() and println():
with the help of print() and println(), we can print the data on the console.

print() is printing on the console, after printing the data the cursor position is in the same line, whereas println() will print the data on the console, after printing the data the cursor position is in the next line.

	ex: s.o.print("hi");
	      s.o.print("bye");
	o/p:  hibye
	**********
	ex: s.o.println("hi");
	      s.o.println("bye");
	o/p:  hi
	         bye

In java we have only "+" operator is overloaded.
'+' is used for both
	1.concatanation
	2. addtion
	
if we are using '+' in between two number datatypes then we will get addition functionalaties.
if we are using '+' in between number and string then we will get concatanation functionalaties.



public class ExplacitCasting {
	public static void main(String[] args) {
		double d = 23.34D;
	float f = (byte)(char)(int)(short)(int)(double)	(long)(float)d;
		byte b1 = 100;
		byte b2 = 20;
		//byte b3 = b1+b2;
		//byte+byte=int.
		int a = 111;
		int b = 222;
		int c = a+b;
		//int+int = int;
		byte b3 = 100;
		int b4 = 100;
		//short b5 = b3+b4;
		//byte+int=int
		short b6 = 100;
		short b7 =  200;
		//short b8 = b6+b7;
		//short + short = int
		//short b9 = b3+b7;
		//byte+short=int
	System.out.println("10+20: "+(10+20));
		int f1 = 111;
		int f2 = 222;
System.out.println("f1"+"+"+"f2:"+" " + (f1+f2));
		System.out.println(11+"ram");
		System.out.println("ram"+22);
		System.out.println("ram"+"22");
		System.out.println(10+20+"ram");
	System.out.println(10+20+"ram"+10+20);
	System.out.println(10+20+"ram"+(10+20));
		//System.out.println(10+false);
		System.out.println("ram"+'A');
		System.out.println('A'+32);
		//int+char = int
		System.out.println(32+'A');
		long ll = 34l;
		float ff = ll;
		long l2 = ll+ff;
		//long+float=float
	}
}



Comments:
	If we want write any statements not related to java grammer rule, then we can write with in the comments.
	Comments are used to provide the information about java elements.
	What ever the code which is available under the comments, that code simply ignored by the compiler, that comments source code not converted into byte code. So JVM is also ignored.
	
	With the help of the comments we can easily understand program.

	java provides three types of comments
	1. Single line comment.
	2. Multiline comment.
	3. Doccument comment.

SingleLineComment: By using this comments we can write only one line of code.
	This can be represent with "//" (two forwars slashes)

Multiline comments: by using this comment we can comment more than one line of code.
	this can be represents with "/*......*/".

Doccument comment:
	This is also same as multiline comment, by using this we can comment more than one line of code.
	this is represent with "/** ......*/"

example:

/*Author: Ram
DOW:14/12/2015
Vendor: nit
java Version: 1.7
*/
public class CommentDemo {
//With out main method we can not execute the //program.
	public static void main(String[] args) {
		/**
		 * int a = 10;
		 *	int b = 20;
	 	 *System.out.println(a+b);
		 */

	}
}
Valid comments:
		// // // //
		// /*    */
		// /**   */
		/*   //   */
		/*   /*  */
		/** /** */
		/** /* */

Invalid comments:
/*   */ */
/**/** */
/**/* */
/**  /*   */   */ 
/* /** */  */

Escape characters:
class EscapeDemo{
static public void main(String...ram){

	//System.out.println("hibye");//hibye
//System.out.println("hi\nbye");//hi
			        //bye
//System.out.println("hi\tbye");//hi      bye
//System.out.println("hi\bbye");//hbye
//System.out.println("hi\ bbye");//error
//System.out.println("hihi\bbye");//hihbye
//System.out.println("hi\rbye");//bye
//System.out.println("hihi\rbye");//byei
//System.out.println("hi\fbye");
//System.out.println("hi\'bye");//hi'bye
System.out.println("hi\"bye");//hi"bye
}
}
Note: dont give any space between '\' and character(t,n,b,r,f,',",\).		

Variable:
	Variable is a named memory location, it can be hold value, the value can be change from one statement to another statement.
	int a = 10;//value --10
	a = a+1;//value--11
	a = a*2;//value--22.

Based on the dataypes variables can be classified into two types.
	1.Primitive Varaible
	2.Referenced Varaible

Primitve Variable:
	A varaible, which can define with the help of primitive datatype is called primitive variable.
	ex: int x=10;
	      float y=45.56f;

drawbacks of Primitive Variable:
	
1. Primitive variables can hold only single value at a time.
     It is unable hold more than one value.
2. If we are placing the data into memory with the help of primitive variables, the data is not stored in the memory in sequential order, the data will be stored in random order.
While retrieving the data from memory will take more time.
3. If we are sending the information from machine to another machine with the help of primitive variable, will take more network calls.
	
if we want resolve above drawabacks then we can go for referenced datatypes.
1.arrays
2.class
3.interface
4.enum

arrays: array is a continuous memory location, which hold more than one value with same datatype.
	int a[] = {10,20,30};
each and every element can recognize, with the help of index position.
With in the one index position, we can write only one value.

Representation of arrays:
	We have three ways to represents arrays.
	1. int a[] = {11,22,33,44};
	2. int b[] = new int[5];
//here 5 is called size or dimentions
//mention the size is mandatory.
	3. int c[] = new int[]{11,22,33,44,55};
Arrays can be represents with help of "[]".

Difference between length field and length():
	
length filed can be applicable on array variables, to know the size of an array.
	int a [] ={0,1,2,3,4,5,6,7,8,9};
	s.o.p(a.length);//10
	
         String s[] = {"kiran","ram","suji","varun","kishore"};
	s.o.p(s.length); //5
	s.o.p(s[4].length()); //7

length() : This is used for to know the number character are existed in string. 
	String s = "internationalization";
	s.o.p(s.length());//20
	String s1 ="ram chandra rao";
	s.o.p(s1.length()); //15

arrays can be classified in the following manner.
	1. Single dimentional array
	2. Double dimentional array
	3. Multi dimentional array

single dimentional array:
	store the elements either in horizontal(rows) or vertical manner(columns).
	ex: int a[] = {111,222,333,444,555};


public class ArrayDemo {

	public static void main(String[] args) {
		int a[] ={111,222,333,444,555};
	/*	System.out.println(a[0]);
		System.out.println(a[1]);
		System.out.println(a[2]);
		System.out.println(a[3]);
		System.out.println(a[4]);*/
		
		for(int i = 0; i < a.length; i = i+1 ){
			System.out.println(a[i]);
		}
	}

}

Java provides 5 ways to read the data from keyboard.
	1. commandline arguments
	2. java.util.Scanner
	3. java.io.BufferedReader
	4. java.io.Console.
	5. java.io.DataInputStream
Command Line Arguments:
	
	passing values at mean while executing the program is called command line argument.
	
syntax:  java ArrayDemo 111 ram 
(click on enter button)
	here 111, ram are called command line arguments.
	what ever the data, which is sending from keyboard to java application, that data is always in the form of string.
	The data may numerical("123"), character(".net"), special character("%^&*").

class CommandLine{
	static public void main(String[] ram){
		String s1 = ram[0];
		String s2 = ram[1];
		System.out.println(s1);
		System.out.println(s2);
             System.out.println("s1+s2: "+(s1+s2));
	}
}
javac CommandLine.java
java CommandLine  php android
php
android
s1+s2: phpandroid
------
java CommandLine 123 234
123
234
s1+s2: 123234
-------
java CommandLine "#$%^"   "&*("
#$%^
&*(
s1+s2: #$%^&*(
=======
invalid execution:
--------------------
java CommandLine    (enter)
java.lang.ArrayIndexOutOfBoundsException: 0
-----------
java CommandLine  123   (enter)
java.lang.ArrayIndexOutOfBoundsException: 1

class CommandLine{
	static public void main(String[] ram){
		String s1 = ram[0];
		System.out.println(s1);
		String s2 = ram[1];
		System.out.println(s2);
		System.out.println(s1+s2);
		int i = Integer.parseInt(s1);
		System.out.println(i);
		int j = Integer.parseInt(s2);
		System.out.println(j);
		System.out.println(i+j);
	}
}
The drawback of above program is , we read the data in the form of string, later we will converting into respective data type(int, boolean, float ......).
so here we are writing some extra logic to read the data in different format. To avoiding this problem, we should go for java.util.Scanner class.

java.util.Scanner:
 Scanner is an one predefine class, which is used to read the data in the different data format.
Different data format means either Stirng,int, byte, short,long,float,double,boolean.
With the help of Scanner class we cannot read character data.

import java.util.Scanner;
public class ScannerDemo {
	public static void main(String[] args) {
		Scanner scan = new Scanner(System.in);
		System.out.println("enter some string value");
		
		String s = scan.nextLine();
		System.out.println(s);
	
		System.out.println("enter some string value");
		String s1 = scan.next();
		System.out.println(s1);
		
		System.out.println("enter some integer data");
		int i = scan.nextInt();
		System.out.println(i);
		
		System.out.println("enter some boolean data");
		boolean b = scan.nextBoolean();
		System.out.println(b);
		
		System.out.println("enter some float data");
		float f = scan.nextFloat();
		System.out.println(f);
		
	}

}
--------------
import java.util.Scanner;
public class ScannerDemo {
	public static void main(String[] args) {
		Scanner scan = new Scanner(System.in);
		System.out.println("enter some string value");
		String s1 = scan.next();
		System.out.println(s1);
		scan.nextLine();
		System.out.println("enter some string value");
		
		String s = scan.nextLine();
		System.out.println(s);
	}
}
Note: In the above program, if we are not 
using obj.nextLine() syntax, then we are unable to read more words by using second nextLine() method. The reasong is next() will read only collection of characters after that if we click enter button, that enter button value will be read by nextLine().
 so we are unable type some words.
to overcome the above problem we need to use one extra nextLine() syntax in our program.

import java.util.Scanner;
public class ArrayDemo1 {

	public static void main(String[] args) {

		int a[] = new int[5];
		Scanner scan = new Scanner(System.in);
		System.out.println("Reading the valued from keyboard");
		for(int i = 0; i < a.length; i = i+1){
			a[i] = scan.nextInt();
		}
		
		System.out.println("printing the values of a array");
		
		for(int i = 0; i< a.length; i++){
			System.out.println(a[i]);
		}
		
	}

}
---------------
//copy the elements from one array to another
public class ArrayDemo1 {
    public static void main(String[] args) {
	int a [] = {11,22,33,44,55};
	int b [] = new int[5];
	for(int i =0; i < a.length ; i++){
		//reading the elements from a array
		//b[i] = a[i];
		for(int j =i; j<i+1; j++ ){
		//placing elements into b array
			b[j] = a[i];
		}
	}
	System.out.println("printing b array elements");
		for(int i =0;i<b.length;i++){
			System.out.println(b[i]);
		}
	}
}

java provides one predefine method for copy the elements from one array to another array.
	
that is arrayCopy(). It is static method, which is available at java.lang.System.
	System.arrayCopy(a,0,b,0,5);

a--->source array
0-->from which index position we are reading the elemen ts
	from source array
b--> destination array
0-->In which index position, we are going to be place the elements in destination array
5-->Number of elements.

Double dimentional array:
import java.util.Scanner;
public class ArrayDemo1 {

	public static void main(String[] args) {
		int a[][] = {{11,22,33},{44,55,66}};
		for(int i =0;i<2 ; i++){//rows
			for(int j=0;j<3;j++){//columns
				System.out.print(a[i][j]+" ");
			}
			System.out.println();
		}
		
	}import java.util.Scanner;
public class ArrayDemo1 {

	public static void main(String[] args) {
		int a[][] = new int[3][3];
System.out.println("enter some data for 3*3 matrix");
Scanner scan = new Scanner(System.in);
		for(int i=0;i<3;i++){
			for(int j=0;j<3;j++){
			a[i][j] = scan.nextInt();
			}
		}
	System.out.println("data from a array");
		for(int i=0;i<3;i++){
			for(int j=0;j<3;j++){
			System.out.print(a[i][j]+" ");
			}
			System.out.println();
		}
	}
}
}
------------------------------
difference between char array to remaining datatype arrays:

If we are printing char array reference varaibel we will get data. if we are print remaining datatype array variables we will reference.(classname@memory)

public class ArrayDemo {
	public static void main(String[] ram) {
		char c[]={'1','a','o'};
		System.out.println(c);
		int a[] = {11,22,33,444};
		System.out.println(a);
		boolean b[] = {false,true,true,false};
		System.out.println(b);
	}
}
-----------------

public class ArrayDemo {
public static void main(String[] ram) {

		byte b[] = new byte[2];
	System.out.println(b.getClass().getName());
		short s[] = new short[3];
	System.out.println(s.getClass().getName());
		int i[] = new int[2];
	System.out.println(i.getClass().getName());
	
		float f[] = new float[3];
	System.out.println(f.getClass().getName()); 
		double d[] = new double[7];
	System.out.println(d.getClass().getName());
		char c[] = new char[1];
	System.out.println(c.getClass().getName());
	System.out.println("****************");
		long l[] = new long[2];
	System.out.println(l.getClass().getName());
		boolean b1[] = new boolean[2];
	System.out.println(b1.getClass().getName());
				
	}
}
-------------------------
annonymous arrays:
	An array, which does not having any external reference, that array is called annonymous array.
	ex: new int[]{11,12,13,14,15};
With the help of annonymous array we can reuse the memory.
Withe the help of annonymous array we can interact with the data only one time.
public class ArrayDemo {
	static void m1(int x[]){
		for(int i=0;i<x.length;i++){
		System.out.println(x[i]);
		}
	System.out.println("***********");
	}
	public static void main(String[] ram) {
		//reference array
	int a[] = new int[]{11,22,33,44};
		m1(a);
		//annonymous array
	m1(new int[]{111,222,333,444});
					
	}
}


Multidimentional Array:
---------------------------
import java.util.Scanner;
public class ArrayDemo {
	public static void main(String[] ram) {
		int a[][][] = new int[2][2][3];
		Scanner scan = new Scanner(System.in);
		System.out.println("please enter integer" +
				" values for 2*2*3 matrix");
		for(int i=0;i<2;i++){
			for(int j=0;j<2;j++){
				for(int k=0;k<3;k++){
					a[i][j][k]= scan.nextInt();
				}
			}
		}
		System.out.println("elements of a array");
		for(int i=0;i<2;i++){
			for(int j=0;j<2;j++){
				for(int k=0;k<3;k++){
					System.out.print(a[i][j][k]+" ");
				}
				System.out.println();
			}
			System.out.println();
		}
	}

}
jagged array:
	if we want to save the memory while inserting the data into the array, we can go for jagged array.

Scanner scan = new Scanner(System.in);
		int a[][] = new int[4][];
		a[0] = new int[1];
		a[1] = new int[2];
		a[2] = new int[3];
		a[3] = new int[4];
		System.out.println("enter elements for jagged array");
		
		for(int i=0;i<4;i++){//rows
			for(int j=0;j<i+1;j++){
				a[i][j] = scan.nextInt();
			}
		}
		System.out.println("a array elements");
		for(int i=0;i<4;i++){//rows
			for(int j=0;j<i+1;j++){
				System.out.print(a[i][j]+" ");
			}System.out.println();
			
		}



Variable: 
----------
Variable is a named memory location, which can be hold the data temporarly.
	The data can be change from one statement to another statement.
	int a = 10;
	a = a*20;
	a=a-100;
syntax:
AccessModifer modifer modifier datatype 		variable_name = value;
example:     public static final int a = 10;

Variable can be classified as two types
	1. Primitive Variables.
	2. Referenced variables.

primitive variable: A variable,which can be declared with the help of primitive datatype is called primitive variable.
	
	int x;	
	float y;
Referenced variables:
	A variable which can be declared with the help of referenced datatype is called referenced variable.
	int x[];
	Student s;
	Runnable r;
	ArrayList al;

Primitive Variable:
Variable can be categorized in two types.
	1. Class level variable
	2. Local variable/method level variable.

Class Level Variable: A variable, which is located at class scope those variable are called class level variable.
	These are two types.
              a. static variable
              b. non-static/instance variable

a.static variables: 
	The variable which have static keyword in its declaration is called static variable.
	static int a  = 111;
In java data is clasified into two types.
	sharabale data
	non-sharable data.

sharable data can be represents with "static" keyword.
In java we can allocate the memory in two ways
	1.static
	2.new
non-sharable data comes under "new" keyword(object).

Before executing main method some static data is going to be executed.
static data means
	static variables
	static blocks 
	static methods.
Before executing main() all static variables and static blocks will be executed, but methods are not executed automatically, if we want to execute we should call explicitly.

All the static variables having same priority, the execution priority is dependupon the way we mention in the program from top to bottom.

variables execution means placing the data into memory.
All the static variables are memorized into two phases.
	1.Loading phase.
	2.Execution/initialization phase.

LoadingPhase: In this phase all the variables are memorized with default values. These default values will be placed by one special component in jvm that is "preparer".

Onec LoadingPhase is completed of all variables,then jvm controle will goes to initialization phase.

Initialization phase:
	In this phase all the default values will be replace with original values/actual values. these original values will be given by one of the special component of jvm that is "initializer".
	static int a = 111;
initially a value is 0 in the loading phase
after 0 will be replaced with 111 in the initialization phase.





public class StaticVariableDemo {
	static int m2(){
		System.out.println(b);
		return 222;
	}
	static  int a = m1();
	public static void main(String[] args) {
		System.out.println("main method");
		System.out.println(a);
		System.out.println(b);
	}

	static int m1(){
		System.out.println(a);
		return 111;
	}
	
	static int b = m2();
}
Accessing the static variable:
	We have three ways to access the static variables.
	1. Class name
	2. Directly (by variable name)
	3. By Object or reference.
Note: If we want to call any otherclass static variable we have only  two ways
	1.classname
	2. object or reference.
we cannot call other class static variable directly.





class A{
	static int b = 222;
}
public class StaticVariableDemo {

	static int a = 111;
	public static void main(String[] args) {
		System.out.println("main method");
		int i = StaticVariableDemo.a;
		System.out.println(i);
		System.out.println(StaticVariableDemo.a);
		int j = A.b;
		System.out.println(j);
		System.out.println(A.b);
		System.out.println("****************");
		int k = a;
		System.out.println(k);
		System.out.println(a);
		
		//System.out.println(b);
		System.out.println("***************");
		StaticVariableDemo sd = new StaticVariableDemo();
		System.out.println(sd.a);
		System.out.println(new StaticVariableDemo().a);
	}

}

Note: static data is sharable data between Objects.
static data having only one memory location.
That memory location can be sharable by all the 
objects in the application.
If any one object is updating the static data, that updated data will be effected to other objects also.
static block:
--------------
	Block means group of statements.
	A block which contains only static keyword, that block is called static block.
	syntax:   static{
		}
	it is used for executing the common logic for all objects before main method. That type of code, we should be write in the static block.
	To initialize the static variables.
	All the static blocks having same priority.
	The execution of static blocks will be dependupon the way we mention in the program from top to bottom.	
	we can not write one static block with in the another static block and also another method, constructor,interface, annotation.

	class A{
		static{}//valid
		static{
			static{}//invalid
		}
		void m1(){
			static{}//invalid
		}
	}
	interface I{
		static{}//invalid
	}

	@interface AAA{
		static{}//invalid
	}
All the static variables and static blocks having same priority. The priority is dependupon the way we mention in the program from top to bottom.

If both static variables and blocks are available in single class, then all static variables loading phase will be first completed. after that both static variables and static blocks will be executed(initialization phase) in the orderwise.

		
loadingphase: in this phase the static data is variable, then jvm provides memory,in that jvm will place default values.
if static data is block and method, then those heading will be read by the jvm and place into some memory.

Initialization phase: In the phase, the static data is variable, then default values will be replaced with original values. If static data is block then automatically block will be executed. If static data is method then not executed, the reason is no method will be executed automatically except main.
	After sucessfully completion of static variable,static blocks execution, then jvm will give chance to main method to execute.

static data can be sharable between all the objects. If any one object is doing modification, that updated value effected to remaing objects also.

note: All the static data are stored in Methodarea.

Non-static data:
	Non-static data comes under
		non-static variable
		non-static blocks
		non-static methods.

Non-static variable:
	A variable which doesnot have any static keyword in its declaration is called non-static variable.
	ex: int a = 111;

	Non-static is not sharable between any two objects.
	If one object is doing modification, that updated value not effected to remaing objects.
	all the non-static data and objects are stored in the heap area.

	Whenever we create an object jvm will do the following things.

static data is loading or memorized only one time for entire application.
As many objects we create in our program, those many times non-static data memeorized/loaded.

Loading phase: if data is non-static variable, then jvm blindly povides memory and place the default values.

if data is non-static block, jvm will read only block heading.

if data is non-static method, jvm will read only method heading.

Initialization phase: If data is non-static variable, then jvm replace the default values with original/actual values.
If data is non-static block then block will be executed by jvm.
If data is non-static method, not executed.
All the non-static variables are having same priority, the execution of variables is dependupon, the way we mention in the program from top to bottom.

public class Nonstatic {
	int a = m1();
	int m2(){
		System.out.println(b);
		System.out.println("m2 method");
		return 222;
	}
	public static void main(String[] args) {
		System.out.println("main method");
		Nonstatic  ns = new Nonstatic();
		
	}
	
	int m1(){
		System.out.println(a);
		System.out.println("m1 method");
		return 111;
	}
	
	int b = m2();
	
	
}
Note: static int a = m1();
"static int a" is comes 
under declaration part.

The space between equal
operator and semicolon is
 called initialization part.

If any method calling 
syntax is available in initialization part, that
must be carry the information from called
area to calling area.

A method which is carry
 the information is called non-void method.

Information must be 
same or  compatable with
variable datatype.

If method having 
returntype, that method
must be have return 
statement with value.
Again value must be 
compatable with return type.


Accessing the non-static variable:
	We have two ways to access the non-static data
		1.by directly.
		2.by object or reference.

//non-static variable we cannot call from static area directly. We should always by using reference or object.

//if we want to call any other class non-static data, we have only one way. That is object or reference.

class B{
	int b = 222;
}
public class Nonstatic {
	int a = 111;
	void m1(){
		System.out.println("m1 method");
		System.out.println(a);
	}
	public static void main(String[] args) {
		System.out.println("main method");
		Nonstatic  ns = new Nonstatic();
		System.out.println(ns.a);
		System.out.println(new Nonstatic().a);
		ns.m1();
		//System.out.println(a);
		//System.out.println(b);
		B obj = new B();
		System.out.println(obj.b);
		System.out.println(new B().b);
	}
}
Non-static data is non sharable between objects. If any one object is doing modification those modification are not effected to other objects the reason every object have its own memory. If we are doing modification on one memory those are not effected to another memory.

public class C {
	int a = 111;
	int b = 222;

	public static void main(String[] args) {
		C obj1 = new C();
		System.out.println(obj1.a);
		System.out.println(obj1.b);
		System.out.println("---------");
		C obj2 = new C();
		System.out.println(obj2.a);
		System.out.println(obj2.b);
		System.out.println("---------");
		obj1.a = 888;
		System.out.println(obj1.a);
		System.out.println(obj1.b);
		System.out.println("---------");
		obj2.a = 999;
		System.out.println(obj2.a);
		System.out.println(obj2.b);
	}

}

Non-static Blocks:
	A block which doesnot contains static keyword in its declaration is called non-static block.
All the non-static blocks having same priority.
The execution priority is dependupon,the way we mention in the program from top to bottom.	

public class C {
	{
System.out.println("non-static block 1");
	}
	{
System.out.println("non-static block 3");
	}
	public static void main(String[] args){
	System.out.println("main method");
		C obj = new C();
	}
	{
	System.out.println("non-static block 2");
	}
}

public class C {
	static {
		System.out.println("static block 1");
	}
	int a = m1();
	{
		System.out.println("non-static block 1");
	}
	static int c = m3();
	int m1(){
		System.out.println(a);
		System.out.println("m1 method");
		return 2222;
	}
	static int m3(){
		System.out.println(c);
		System.out.println("m3 method");
		return 4444;
	}
	{
		System.out.println("non-static block 3");
	}
	int b = m2();
	public static void main(String[] args) {
		System.out.println("main method");
		C obj = new C();
		System.out.println(obj.a);
		System.out.println(obj.b);
	}
	
	{
		System.out.println("non-static block 2");
	}
	int m2(){
		System.out.println(b);
		System.out.println("m2 method");
		return 3333;
	}

}


valid statement:
	{
		{
		}
	}

	static{
		{
		}
	}
	C(){
		{
		}
	}

interface D{
	//{}
}
enum E{
	;
	{
			
	}
}
abstract class F{
	{
		
	}
}
@interface I{
	//{}
}
public class C {
	{
		System.out.println("non-static block 1");
		{
			System.out.println("non-static inner block 1 ");
		}
	}
	static{
		System.out.println("static block 1");
		{
			System.out.println("non-static inner block2");
		}
	}
	C(){
		System.out.println("constructor");
		{
			System.out.println("non-static inner block 3");
		}
	}
	static void m2(){
		{
			System.out.println("m2 method non-static block");
		}
	}
	public static void main(String[] args) {
		{
			System.out.println("main method non-static block");
		}
		System.out.println("mainmethod");
		C obj = new C();
	}
}
Non-static block we can write with in the class, enum,abstract class, staticblock, static method, non-static method,constructor but we can not write in interface and annotation.

static block we can write only within he class, enum, abstract class.

Q)  Difference between static and new keyword?
static: 
1)It is a keyword, is used allocate the memory for static data.
2)static data means, static ariable,blocks, methods.
3)static data is sharable data
4)static data having only one memory
5)only one time static data is loaded.
6)If any one object is doing updation on static data, that updated value will be effected to remaining objects.
7) Meanwhile of class loading static-data is loaded by the jvm.
8) Static data can be acces with in 3 ways.
directly,classname,object or reference.
9)static data we can call any where in the program.
10) other class static can be access only in two ways.	a.by classname
	b.by object or reference
new: 
1)It is keyword is used to allocate the memory for non-static data.
2)non-static data means, non-static variables, non-static blocks , non-staic methods.
we have one more name to non-static data that is instance data.
3)non-static data is non-sharable data.
4)non-static data having multiple memory.
5)as many object we created those many times non-static data is going to be loaded.
6)If any one object is doing updation on non-static data, that updated data/value will not be effected to remaining objects.
7)Meanwhile of object creation non-static data executed.
8)non-static can be acces in two ways.
by using directly,object or reference.
9)non-static we cannot call directly in static area.
10) other class non-static can be access only in one way.
	
	a.by object or reference
	     nsb	sb	constructor
throw            no	no	yes
return 	      no	no	yes
returnwivale no	no 	no

Local variable: A variable, which is resides or locate within the parameter of an method, constructor and body of method,constructor, block(static,non-static) is called local variable.



	ex:
	 void m1(int x){
		int y;

	 }
	{
		int z;
	}
	static{
		int l;
	}
	class  A{
		A(int n){
			int m;
		}
	}
	
x,y,z,l,m,n all are local variables.
local variables always either default or final.
	void m1(){
		int a;		//valid
		final int b;	//valid
		private int x;	//invalid
		public int y;	//invalid
		protected int z;	//invalid
		static int l;	//invalid
		transient int m;	//invalid
		volatile int n;	//invalid
			
	}
Local variables may be default or final.
there is no default values for local variables.
Before using local variables we should be initialize.
if we are using local variables without initialization, we will get one compiletime error.
Same variable name we can declare in different scopes.
final keyword we can be applied on variables, method, classes.

Meanwhile of block execution local variables are going to be memorized and after block execution completed all the local variables  are destroyed.	
final variables:
	A variable which have final keyword in its declaration is called final variable.
final keyword we can be applied on top of class level and local variables also.
	
	class level final variable must be initialized meanwhile of declaration.
	local level final variable must be initialized before using that variable.

final variable can be use more than one time but we can not update/change the data.
If we are trying to change we will get CE.

final class Student{
	String sname="suji";
}
public class FinalVariable {
	final int a = m1();
	//final int b; //class level final variable must be
	//intialize mean while of declaration.
	int m1(){
		System.out.println(a);
		System.out.println("m1 method");
		return 111;
	}
	final void m2(){
		System.out.println("m2 method");
	}
	static void m3(final int x){
		System.out.println(x);
		//x=x+1;
	}
	public static void main(String[] args) {
		FinalVariable fv = new FinalVariable();
		System.out.println(fv.a);
		//fv.a = fv.a*2;
		int c = fv.a*2;
		final int d;
		d=888;
		System.out.println(d);
		Student s = new Student();
		System.out.println(s.sname);
		s.sname="ram";
		System.out.println(s.sname);
		fv.m2();
	}

}

Scope of variables: 

Local variables: only with in the block(method, constructor,static and non-static block).
	
Non-static variable: Based on object. once objecte created automatically non-static variables loaded, once object is destroy non-static variables are destroyed.

static variable: Based on bytecode(.class).



Referenced Variables:
Referenced variables are categorized into two types.
	1.Class level referenced variable
	2. Local referenced variable.
	
Class level referenced variable:
	A referenced vairble available at class level is called CLRV.
	It has been categorized into two types
	a. static referenced variable
	b. non-static/instance referenced variable.
	class Student{
		Student s = new Student();
	static Student s1 = new Student();
	}
Local referneced variable: 
	A variables which is available at block or method level is called LRV.
	ex: 
	class Student(){
		psv main(-){
		Student s = new Student();
		}
	}

arrays can hold more than one value with same type, but it is unable hold different type of data , to overcome this problem then we can go for another referenced datatype is called "class".

Class is an imaginary thing, which is not existed in the real world.
Class is a model.
Class is a model for creating objects. Means the properties and actions of the objects are written in the class.
Properties are represented by variables.
Actions of the objects are represented by methods.
So a class contains variables and methods.
The same variable and methods are also available in the objects because they are created from the class.
These variables are also called as instances.
How can we provide functionality to a class?   
A)By creating an object.
Object:
Whatever the functionalities the class having, we should get those functionalities by creating object only. 
creating an object is nothing but, allocating memory, necessary to store the actual data of the variable.
By creating the object only, we can give the memory to name, age variables

class def:  It is a java element, it can be hold both static and  non-static variables, static and non-static method, static and non-static block, both static and non-static innerclass,interface, enum.
	
Object Creation:
In java we have 5 ways to create an object.
1.new keyword
2.clone()
3.newInstance()
4.Factory  methods.	
	a.static factory methods
	b.non-static factory methods
5.Deserialization.
1. new Keyword:
	in java we can create two types of objects.
	a. referenced object.
	b. un-referenced object.
referenced object creation:
classname reference_name = new classname();

When ever jvm see the new keyword blindly provides new memory.
With the helpof referenced object creation we can reuse the memory more than one time.

Unreferenced object cretion:
	new classname();
With help of unreferenced object we can use the memory only one time.
	
With the help of object we can communicate with both static and non-static data also.
	class Student {
		int a = 111;
		int b = 222;
		psv main(){
		Student s1 = new Student();
		new Student();
		}
	}
Difference between object and reference:
	Object means allocating memeory.
	Reference means holding the memory, which is generated by object.
	But both object and reference will pointing to same memory.
	With the help of reference, we can use the same memory more than one time.
	With the help of object, we can use the memory only one time.		


public class SRV {
		int x = 100;
		int y = 200;
	
	public static void main(String[] args) {
		
		SRV obj = new SRV();
		
		System.out.println(obj.x);
		
		System.out.println(obj.y);
	
		new SRV();
		
		int a = new SRV().x;
		
		int b = new SRV().y;
		
		System.out.println(new SRV().x);
		
		System.out.println(new SRV().y);
	}

}

public class SRV {
	SRV obj = new SRV();
	public static void main(String[] args) {
		
		SRV obj1 = new SRV();
		
	}
		
	/*static SRV obj = new SRV();
	public static void main(String[] args) {
		
		SRV obj1 = new SRV();
		System.out.println(obj1);
		System.out.println(obj);
	}*/
}

public class SRV {
	int a = 111;
	static int b = 222;
	public static void main(String[] args) {
		int a = 333;
		int b = 444;
		SRV obj = new SRV();
		System.out.println(a);
		System.out.println(obj.a);
		System.out.println(obj.b);
		System.out.println(b);
	}
}
jvm always gives priority to local data.
if we are calling variable directly first compiler will with in the local area(block), if not then it will goto class level.

s.o.p(obj.a) then compiler directly check in object are(heap area), if available that a value bind to obj, then jvm will print a value in runtime. 

if not compiler will check in the method area/static are
if available compiler will bind the data to obj, then jvm will print a value in runtime.
if not compile time error.
public class NSD {
	static int b = 333;
	int a = 111;
//static int a = 222;
//same we cannot be define more than one time 
//in the same scope
public static void main(String[] args) {
		int a = 222;
		System.out.println(a);(1)
		new NSD();//no use
	System.out.println(new NSD().a);(2)
		NSD ns = new NSD();
		System.out.println(ns.a);(3)
		System.out.println(ns.b);(4)
	System.out.println(NSD.b);(5)
		System.out.println(b);(6)
	}
}
Note: 
in step 1) jvm will give priority to local data first 
if data is not available in block level(jsa) then controle goes to method area.
2)jvm control directly goes to heap area if not available then goes to method area
3) same as .

4)same as 2
5) same controle directly goes to method area
6) jvm controle goes to jsa, if not available then control to goes to method area 

Scopes of variables:
	We have two scopes .
		1.class scope 2. block scope
class scope variables we can access with in the entire class level 
block scope variables we can access with in the same scope.

class Student1{
	int sid = 111;
	String sname = "suji";
}
public class SRV {
public static void main(String[] args) {
	Student1 s1 = new Student1();
	Student1 s2 = new Student1();
	Student1 s3 = new Student1();
System.out.println("s1: "+s1.sid			+"...."+s1.sname);
System.out.println("s2: "+s2.sid			+"...."+s2.sname);
System.out.println("s3: "+s3.sid			+"...."+s3.sname);
	}
}
output:
s1: 111....suji
s2: 111....suji
s3: 111....suji
In above	program we are getting same id,name for all the students, it is not possible in real time, to avoid this drawback we should provides different values for different students. If we want to achieve this requirement then we can go for constructors.

Constructors:
Constructors are special blocks in class level, to initialize the non-static varaibles.

Constructors are used to creating object.
Constructors are class level blocks.
Constructor name is same as class name.

After succesfully executing of all non-static variables, blocks then constructors will be executed.
Once constructor is sucessfully executed,then we can say this, our object is sucessfully initialized.
Constructors are plays major role in object creation.
In constructor block we can write throwskeyword and return statement without value. But we cannot write return statement with value. 
Without constructor we cannot create object for a class "with new keyword".
	Constructors are three types.
	a.default constructor
	b.zero argument/non-parameterized constructor
	c. parameterized/argumented constructor

Default constructor:
	If we are not specify any constructor in our class by default compiler will provide one constructor with zero parameters is called default constructor.
	In that default constructor compiler will provides one non-static variable that is "super()".

ex:   class A{

        }
javac A.java
javap A
	class A extends java.lang.Object{
		A(){
			super();
		}
	}
javap command is used to check the .class files information.
javap command always needs fullyqualified name(packagename + classname/interfacename/  enum/abstract class/annotaion).

If our class is public compiler generated constructor also public.
If our class is default compiler generated constructor also default.
we cannot write protected, private, static, native, volatile, transient, synchronized modifiers infront of outer class name.
we can write only default,public,final,abstract,  strictfp in frontof the outer class names.


Zero-argument constructor:
	The constructor, which is created by the programmer without any argument is called zero arguemnt constructor.
	public class A{
		A(){//zero argument
		}
	}
Parmeterized constructor:
	The constructor, which is created by the programmer with argument/parameters is called parameterized constructor.
The parameter count must be atleast one.
	ex:
	class Student{
		Student(){//zero argument
		}
                           Student(int x){//parameterized
		}
	}	
Within the one class we can write multiple constructors.
--------------
class Student1{
	int sid = m1();
	int m1(){
		System.out.println(sid);
		System.out.println("m1 method");
		return 111;
	}
	Student1(){
            System.out.println("zero argument constructor");
	}
	{
		System.out.println("non-static block");
	}
	Student1(int x){
               System.out.println("parameterized constructor");
		System.out.println(x);
	}
}
public class SRV {
	public static void main(String[] args) {
		Student1 s1 = new Student1();
		Student1 s2 = new Student1(200);
	}
}

For single object creation only one respectable constructor is executed.
If we want create an object we need respective constructor otherwise we will not create object with the help of new keyword.
As many object we created those many times non-static variables,blocks,constructors(respective) will be executed.

Object creation means communicating with the constructor only for initializing the non-static data/variables and forwarding the controle from sub class to super class with the help of super keyword.

Constructor overloading:
Wring the same constructor more than one time with in the same class with different parameters is called constructor overloading.
	class A{
		A(){}
		A(int x){}
		A(float y){}
		A(int x, float y){}
		A(float x, int y){}
	}
Note: dont consider variable names.
note: one class constructor can not be placed in another class.
	class A{
		B(){//invalid
		}
	}
	class B{
	}
Excuting the non-static variable and blcoks is called object creation.
Excuting constructor is called object initialization

Constructor chaining:
	Comunicating with one constructor to another constructor is called constructor chaining.
	If we want develop constructor chaining in java, we need any one of these keywords
	1.this.
	2.super.

class Student{
	int sid;
	String sname;
	Student(){
		this(111);
System.out.println("zero argument constructor");
	}
	Student(int x){
		this("ram");
		System.out.println("single int parmeterized constructor");
		System.out.println(x);
	}
	Student(String s){
		System.out.println("single String parmeterized constructor");
		System.out.println(s);
	}
}
public class ConstructorChaining {
	public static void main(String[] args) {
		Student s = new Student();
	}

}
=================
class B{
	B(int x){
		System.out.println("super class int argument");
	}
}
class C extends B{
	
}
In the above code we will get compile time error.
The reason is in the C class compiler will provide default constructor and super()(zero argument).
like as bellow
	class C extends java.lang.Object{
		C(){
			super();
		}
	}
But in the super class we dont have any zero argument constructor.
Note: If super class not having any zero argument constructor, in the sub class programmer must be write constructor and with appropriate super() with argument.
package reference;

class B{
	B(){
		System.out.println("super class int argument");
	}
}
class C extends B{
	private C(){
		
	}
	
	public static  C getC(){
		return new C();
	}
	
	int a = 111;
}
public class ConstructorChaining {
	public static void main(String[] args) {
		//C obj = new C();
		C obj1 = C.getC();
		System.out.println(obj1.a);
	}

}
If any class having private constructor, that class must be have static factory method to communicate its(class) non-static data.
Singleton Design pattern:
------------------------
	SDP represents allocating memory for a particular only one time, the same memory can be use multiple times. With the SDP we can save the memory.
	If we want to develop SDP class we need one private constructor and public static reference variable and one static factory method.
class Servlet{
public static Servlet obj = new Servlet();
	private Servlet(){
	}
	public static Servlet getServlet(){
		return obj;
	}
}
public class SingletonDesignPattern {
public static void main(String[] args) {
	//System.out.println(new Servlet());

	Servlet obj1 = Servlet.getServlet();
	Servlet obj2 = Servlet.getServlet();
	System.out.println(obj1.hashCode());
		System.out.println(obj2.hashCode());
		
	}

}	
Copy Constructor:

Placing one object data into another object is called copy constructor.

The constructor which have same class reference variable as parameter is called copy constructor.
package inheritance;

class Student{
	int sid ;
	String sname;
	int sage;
	
	Student(int sid,String sname,int sage){
		this.sid = sid;
		this.sname = sname;
		this.sage = sage;
	}
	
	Student(Student obj){//copy constructor
		this.sid = obj.sid;
		this.sname = obj.sname;
		this.sage = obj.sage;
	}
}
public class CopyConstructor {

	public static void main(String[] args) {
		Student s = new Student(101,"mounika",25);
		Student s1 = new Student(s);
		System.out.println("s: "+s.sid+"..."+s.sname+".."+s.sage);
		System.out.println("s1: "+s1.sid+"..."+s1.sname+".."+s1.sage);
	}

}













"this" keyword:
------------------
	this is a non-static final reference variable, which can be created by jvm, meanwhile of object creation,to hold current object.

1) this keyword is a non-static final reference variable.
2) this keyword can not be used from static area(static method,static block). It can be accessed only within the non-static area(non-static method, non-static block,constructor).

public class ThisDemo {
	int a = 111;
	public static void main(String[] args) 		{
	ThisDemo td = new ThisDemo();
	System.out.println(td.a);
	//System.out.println(this.a);
	}
}
3) we cannot change the value of this keyword.

public class ThisDemo {
	int a = 111;
	void m1(){
	System.out.println(this);
	//System.out.println(this+100);
	}
	public static void main(String[] args) 	{
	ThisDemo td = new ThisDemo();
	System.out.println(td.a);
	//System.out.println(this.a);
	td.m1();
	}
}
4)Whenever we calling m1() on top of td reference(current object), the m1() is going to be executed, in the meanwhile td reference value is also going to m1(). 
If we want to hold td reference value in m1() we need "this" keyword.
5) this  keyword is also communicating with both static and non-static data.
6) this keyword is used to make a communication between constructor, with in the same class.

7) this keyword must be first statement in the constructor.
8) we should leave one constructor for "super" keyword.
	that means we can not use this keyword in all constructor.
9) we can not call same constructor, within  its body.

class Student{
	Student(){
		this(111);
System.out.println("zero arguement constructor");
		//this();
	}
	Student(int x){
		//this();
		System.out.println("parmeterized constructor");
	}
}
public class ThisDemo {
	int a = 111;
	static int b = 222;
	void m1(){
		System.out.println(this.a);
		System.out.println(this.b);
	}
	public static void main(String[] args) {
	ThisDemo td = new ThisDemo();
		td.m1();
		Student s = new Student();
	}
}
public class ThisDemo {
	int a = 111;
	static int b = 222;
	static {
		System.out.println("static block");
		//System.out.println(this);
	}
	
	ThisDemo(){
	System.out.println("constructor: "+this);
	}
	{
	System.out.println("non-static block");
	System.out.println("nsb:****** "+this);
	}
	void m1(){
		System.out.println("m1: "+this);
		//System.out.println(this++);
		System.out.println("m1 method");
		System.out.println(this.a);
		System.out.println(this. b);
	}
	public static void main(String[] args) {
		System.out.println("main method");
		//System.out.println(this);
		ThisDemo td = new ThisDemo();
		System.out.println("td: "+td);
		td.m1();
		System.out.println("********");
		ThisDemo td1 = new ThisDemo();
		System.out.println("td1:"+td1);
		td.m1();
	}

}

10) this keyword is used forwarding the current object to another method as an argument.
class Student{
void m1(){
	System.out.println("m1 method");
	System.out.println("this: "+this);
	m2(this);//compiler conver into this.m2(this);
	System.out.println("--------------");
	Student s1 = new Student();
	System.out.println("s1: "+s1);
	m2(s1);//compiler conver into this.m2(s1);
	System.out.println("--------------");
	m2(new Student());//compiler convert into 			//   this.m2(new Student());
	System.out.println("--------------");
	m2(this);
	}
	void m2(Student s){
System.out.println("m2 method s: "+s);
	}
}
public class ThisDemo {
	public static void main(String[] args) {
		Student s = new Student();
		System.out.println("s: "+s);
		s.m1();
	}

}

11) this is used to differentiate class level variable to local varaible.
class Student{
	int sid = 111;
	String sname = "ram";
	/*Student(int id, String name){
	sid = id;             //this.sid = id;
	sname = name;//this.sname = name;
	}*/
	/*Student(int sid, String sname){
		sid = sid;
		sname = sname;
	}*/
	Student(int sid, String sname){
		this.sid = sid;
		this.sname = sname;
	}
}
public class ThisDemo {
   public static void main(String[] args) {
	Student s = new Student(222,"suji");
	System.out.println(s.sid);
	System.out.println(s.sname);
    }

}
super keyword:
	super keywords is an non-static final reference variable, to make communication between subclass constructor to superclass constructor.

	Whenever using extends keyword what ever the data which is available in superclass that data will comes to subclass. If we want extract the data first we need to forward our controle from subclass to superclass.
	For this purpose we need one predefine keyword that is "super".

	If we are not writing any super(),this() in constructor then compiler will place super(), in our constructor.
	with in the single constructor we can write either this() or super(), we cannot write both. The reason is both super() and this() always needs first statement in the constructor.
	
	All static and non-static variable,static and non-static block and constructor are loaded from super class to sub class.

class A extends java.lang.Object{
	int a = m1();
	static int b = m2();
	int m1(){
		System.out.println(a);
		System.out.println("A class non-static m1 method");
		return 111;
	}
	A(){
		super();
		System.out.println("A class constructor");
	}
	static{
		System.out.println("A class static block");
	}
	{
		System.out.println("A class non-static block");
	}
	static int m2(){
		System.out.println(b);
		System.out.println("A class static m2 method");
		return 222;
	}
}
class B extends A{
	int c = m3();
	static int d = m4();
	int m3(){
		System.out.println(c);
		System.out.println("B class non-static m3 method");
		return 333;
	}
	B(){
		super();
		System.out.println("B class constructor");
	}
	B(int x){
		super();
		//this();
		
		System.out.println("B class argument constructor");
	}
	static{
		System.out.println("B class static block");
	}
	{
		System.out.println("B class non-static block");
	}
	static int m4(){
		System.out.println(d);
		System.out.println("B class static m4 method");
		return 444;
	}
}
public class SuperDemo {
	public static void main(String[] args) {
		B obj = new B();
		
	}

}


	"super" is used to differentiate the subclass variable to super class variable.

	"super" is used to differentiate the subclass method to super class method.		

	"super" keyword can not used in static area.

	with the help of super keyword we can call both 
static and non-static data.

	super keyword always represent super class memory.

package constructor;
class B{
	int a = 111;
	static int b = 222;
	void m1(){
		System.out.println("B class non-static m1()");
	}
	static void m2(){
		System.out.println("B class static m2()");
	}
}
public class SuperDemo extends B{
	int a = 333;
	static int b = 444;
	void m1(){
		int a = 555;
		System.out.println("SuperDemo class non-static m1()");
		System.out.println(a);
		System.out.println(this.a);
		System.out.println(super.a);
		System.out.println(b);
		System.out.println(this.b);
		System.out.println(super.b);
		m2();//this.m2();
		this.m2();
		super.m2(); 
		super.m1();
	}
	static void m2(){
		System.out.println("SuperDemo class static m2()");
	}	
	public static void main(String[] args) {
		//System.out.println(super.a);
		SuperDemo td = new SuperDemo();
		td.m1();
	}
}

Methods:
	In java every value is hold by the variables.
If we want to update the value of an variables, we need some logic or operations.
	In java, we can not do the operations in class level or we can not write logic in the class level.

So if we want to do the operations in java we have the following areas.
	1. static Block.
	2. Non-static block.
	3. Constructors.
	4. Methods.

If we are writing logic or operation in static block, that static block logic can be executed only one time, if we want to execute more than one we can not call explicitly.

If we are writing logic or operation in non-static block and constructor, those blocks execution need object creation, if we are executing those blocks multiple times, programmer should create mutltiple objects.
If we are keep on creating objects then we are unnecessarly wasting our memory.

 To avoiding above drawbacks we have one special block in class level that is method.
We can execute the method multiple times based on our requirement.

The difference between block and method is blocks automatically executed whereas methods not executed, we need to call explicitly. Blocks does not have any specific name to call,whereas method have specific name to call.

Methods are mainly design for carraying the information from one place to another place and also used to holding the logic.

	ex: 
class A{
	System.out.pritnln("not valid");//invalid
	static {
		s.o.p("only one time executed");
	}	
	{
		s.o.p("object creation mandatory");
	}
	A(){
		s.o.p("object creation mandatory");
	}
	void m1(){
	s.o.p("writing the logic in method very flexible");
	}	
}
Note: No method will be executed automatically, except main method.

Each and every class having it own functionalities, we can achieve these functionalities through methods.
 class Account{
	double accountNo=123456789;
	String accHoldName="bhuvana";
	double amout=10000;
}
class Deposit{
	public void deposit(int amount){
		Account acc = new Account();
		acc.amout = acc.amout+amount;
	}
}
class Withdrawl{
	public void withdrawl(int amount){
		Account acc = new Account();
		acc.amount=acc.amount-amount;
	}
}
class Transaction{
	psvm(--){
		Deposit d = new Deposit();
		d.deposit(10000);
		Withdrawl w = new  Withdrawl();
		w.withdrawl(5000);
               	}
}
note: in the above program every class has it own functionalaties, we can differentiate with the help of different methods.


According to above information we can specify “method” is a block in the class, which contains set of statements, mostly we can say about these statements are called as actions or behavior or operation of a class.



All these statement have its own logic according to class specification.

That means each and every class has its own action and behavior.

For example sports class does not contain logic of Faculty class.

So the conclusion is, the logic of statements, which are located in the sports class method is different from logic of statements, which are located in the Faculty class methods.

The logic of a statements must be written in a method, not outside of a method.

If we attempt to write logic out side of method, the compiler will display the error message called as “identifier expected” System.out.println("hi”);

Getting Modularity(differentiate from one logic to another logic).

We are always writing one logic in one method.

Reduce Time Consuming.	

note: java doesnot allow nested methods.
Types of methods:
	
Based  on modifier:
	a.static methods
	b.non-static methods
Based on returntype:
	a.void methods
	b.non-void methods
Based on parameters
	a.parameterized method
	b.non-parameterized method
Factory methods.
	a.static factory methods
	b.non-static factory methods
	
Based on body:
	a.abstract methods.
	b.concrete methods.

Based On modifier:
	a.static methods: A method which contains static keyword in its declaration or definition is called static method.
	ex: 
	static void m1(){
	}
	static int m2(){
		return 100;
	}
	static void m3(int x){
	}
	
static methods can be called by using the following ways.
	1. By directly(method name)
	2. By classname
	3. by object or reference.
Note: Other class static method can be call by using two ways only 
	1. by classname
	2.by object or reference

	b.Non-static methods: A method which doesnot have static keyword in its declaration or definition is called non-static method.
	ex:
	void m1(){
	}
	int m2(){
		return 111;
	}
	void m3(int x){
	}

we can call non-static method by using two ways.
	1.by directly
	2.by object or reference
Nore: other class non-static can be call by using object or reference only.
class AA{
	static void m3(){
		System.out.println("AA class static m3 method");
	}
	void m4(){
		System.out.println("AA class non-staticm4 method");
	}
}
public class MethodDemo {

	static void m1(){
		System.out.println("this is static m1 method");
	}
	void m2(){
		System.out.println("this is non-static m2 method");
		m5();
	}
	void m5(){
		System.out.println("this is non-static m5 method");
	}
	public static void main(String[] args) {
		m1();
		MethodDemo.m1();
		MethodDemo md = new MethodDemo();
		md.m1();
		new MethodDemo().m1();
		AA.m3();
		AA obj = new AA();
		obj.m3();
		new AA().m3();
		System.out.println("---------------");
		//m2();
		md.m2();
		obj.m4();
	}
}
Note: we cannot call non-static data directly from static area.(method/block)

Based on method return type:
	a.void method:
A method, which doesnot carrying any information from one place to another place is called void method.
void means nothing to define.(void means not zero,not flase,not null  simply nothing to define).

with in the void methods we can write return statment.
the return statement must be without value.

Note: void method can not be call from System.out.println().
	void m1(){
	}
	s.o.p(m1());//invalid

ex:   void m1(){
	return ;
	//return 100;//invalid
        }

b.Non-void method:
	A method, which carrying the information is called non-void method.
Here information means
	a.primitive type
	b.primitive arraytype
	c.referenced type
	d. referenced array type
every non-void method must be ended with return statement with respective value.
we can call non-void methods from s.o.p() statement.	

Calling Method: A method which is calling to another method, that method is called "CallingMethod".

Called method: A method, which is called by other method, is called "CalledMethod".

class NStudent{
	String name="ramcharan";
}
public class MethodDemo {
	void m1(){
		System.out.println("non -static void m1()");
		m2();
		return; 
	}
	static void m2(){
		System.out.println("static void m2()");
		//return 100;
	}
	int m3(){
		System.out.println("m3 method");
		return 100;
	}
	boolean m4(){
		System.out.println("m4 method");
		return false;
	}
	String m5(){
		System.out.println("m5 method");
		return "ram";
	}
	
	int[] m6(){
		System.out.println("m6 method");
		//int a[] ={10,20,30};
		//return a;
		int a =11;
		int b= 22;
		int c=33;
		//return new int[]{a,b,c};
		return new int[]{11,22,33};
	}
	NStudent m7(){
		System.out.println("m6 method");
		NStudent n = new NStudent();
		return n;
	}
	NStudent[] m8(){
		System.out.println("m6 method");
		NStudent n1 = new NStudent();
		NStudent n2 = new NStudent();
		NStudent n3 = new NStudent();
		NStudent n4[]={n1,n2,n3};
		//return n4;
		//return new NStudent[]{n1,n2,n3};
		
		return new NStudent[]{new NStudent(),new NStudent(),
				new NStudent()};
		
	}
	public static void main(String[] args) {
		m2();
		//System.out.println(m2());
		MethodDemo md = new MethodDemo();
		md.m1();
		//System.out.println(md.m1());
		System.out.println(md.m3());
		System.out.println(md.m4());
		System.out.println(md.m5());
		System.out.println(md.m6());
		int a[] = md.m6();
		for(int i=0;i<a.length;i++){
			System.out.println(a[i]);
		}
		System.out.println(md.m7());
		NStudent ns = md.m7();
		System.out.println(ns.name);
		
		NStudent[] ns1 = md.m8();
		for(int i=0;i<ns1.length;i++){
			System.out.println(ns1[i].name);
		}
		
	}
}

Based on Parameter:
a. zero arguement method/non-parameterized method.
	A method, which doesnot have any parameters in its parameter place is called non-parameterized method.
	ex: 
	void m1(    ){
	}
	int m2(   ){
		return 111;
	}
	
b. parameterized method: 
	A method, which contains parameters is called parameterized method.
	The paraeters may be
	a.primtive type
	b.primtive arraytype/reference
	c.referenced  type
	d.referenced arraytype.

	void m1(int x){
	}
	void m2(int x[]){
	}
	void m3(Student s){
	}
	void m4(Student s[]){
	}

import java.util.Scanner;
class MMM{
	int x=999;
}
class PANP{
	void m1(    ){
		System.out.println("non-parameterized m1() method");
	}
	void m2(int x){
		System.out.println("param m2 method");
		System.out.println(x);
	}
	void m3(String x){
		System.out.println("param m3 method");
		System.out.println(x);
	}
	void m4(String x[]){
		System.out.println("param m4 method");
		for(int i=0;i<x.length;i++){
			System.out.println(x[i]);
		}
	}
	void m5(int x,String y){
		System.out.println("param m5 method");
		System.out.println(x);
		System.out.println(y);
	}
	void m6(MMM obj){
		System.out.println("m6 method");
		System.out.println(obj);
		System.out.println(obj.x);
	}
}
public class Demo {
	public static void main(String[] args) {
		PANP obj = new PANP();
		MMM obj1 = new MMM ();
		obj.m6(obj1);
		obj.m6(new MMM());
		obj.m1();
		obj.m2(111);
		obj.m3("abhinava");
		String s[] = {"ram","java","php","oracle"};
		obj.m4(s);
		String s1[] = new String[]{"cobol","naresh i","techonologies"};
		obj.m4(s1);
		obj.m4(new String[]{"maths","english","telugu"});
		String s2[] = new String[3];
		Scanner scan = new Scanner(System.in);
		System.out.println("enter some string values");
		for(int i=0;i<s2.length;i++){
			s2[i]= scan.next();
		}
		obj.m4(s2);
		obj.m5(111,"basha");
		
	}

}
AbstractMethod:
	A method which does not having body is called abstract method.
	abstract method is always ended with semicolon(;).
	abstract method must be need " abstract " keywrod in its declaration.
	abstract method always provides specification.
If we want to use those method we need to provide implementation for specification.
	ex: abstract void m1();

Concrete method: A method which has body is called concrete method.
	ex: void m1(){
		
	      }
DataHiding:
	The data which is not accessible from out side of the class is called datahinding.
	we can achieve datahiding concept with the help of private access modifier.
	class A{
		private int i=111;
		private int j = 222;
	}

Data abstraction: 
	Hiding the implementation logic from user to another user is called data abstraction.
we can achieve this data abstraction with the help of abstract keyword.
	class A{
		private int i;
		public setI(int i){
			this.i = i;
		}
	}

class X{			class Y{
 psvm(){			   psvm(){
   A obj = new A();	                    A obj = new A();
    obj.setI(111);		        obj.setI(222);
 }			    }
}			}

In above syntax setI() will hide the both X,Y class logics.

Encapsulation: 
	Placing the object information into a class is called encapsulation.
	Hiding the information with the help of private modifier and accessing that hiding information with the help of public methods from outside of the program is called encapsulation.

private data we can access outside of the class by using public method and reflection api.
class Bank{
	private long accountNo;
	private String accountHoldName;
	private double amount;
	
	
	public void setAccountNo(long accountNo) {
		this.accountNo = accountNo;
	}
	public long getAccountNo() {
		return accountNo;
	}  
	
	public void setAccountHoldName(String accountHoldName) {
		this.accountHoldName = accountHoldName;
	}
	public String getAccountHoldName() {
		return accountHoldName;
	}
	
	public void setAmount(double amount) {
		this.amount = amount;
	}
	public double getAmount() {
		return amount;
	}
	
	
}
public class EncapsulationDemo {

	public static void main(String[] args) {
		Bank obj = new Bank();
		obj.setAccountNo(35568987);
		obj.setAccountHoldName("Srinivas");
		obj.setAmount(5000);
		
	
		long accountNo = obj.getAccountNo();
		String accountHoldName = obj.getAccountHoldName();
		double amount = obj.getAmount();
		
		System.out.println(accountNo+"   "+accountHoldName+"   "+amount);	}

}









================
class A{
public static void main(String...ram){
B obj = new B();
System.out.println(obj.a);
}
}
FileName: A.java
Steps to load the B's class information:
--> compiler will check B class information in A.java file.If not available
--> compiler will check B.class in current working directory. If not available
-->compiler will check B.java file in cwd. If not available compiler will one error, that is cannot find symbol class B.
-----------------------------
If B.java file is available in cwd then B.java file converted into B.class file then that bytecode will be used in A.java file..
------------------------------
If B.class file is available, then compiler check B.java file available or not. If B.java file not available only B.class available then compiler use B.class file information in A.java file.
---------------------------------------
If both B.class and B.java file are available then compiler will check both file creation time. If B.class file creation time is more than B.java file then compiler blindly use B.class file.
Otherwise means B.java file creation time is more than the B.class file creation time then compiler first compile B.java file and updated the existed B.class with new B.class file information, later compiler use updated B.class file information.
















Singleton Design pattern:
	
	To stop to create multiple object for a particular class is called singleton design pattern.
	With the help of singleton design patter we can save the memory.
	ex: Servlet.
	
class Bank{
		private static Bank b = new Bank();
		private Bank(){
		System.out.println("Bank constructor");
		}
		public static Bank getObject(){
			return b;
		}
}
public class SingletonDemo {

	public static void main(String[] args) {
		//Bank b = new Bank();
		Bank obj = Bank.getObject();
		System.out.println(obj);
		Bank obj1 = Bank.getObject();
		System.out.println(obj1);
		Bank obj2 = Bank.getObject();
		System.out.println(obj2);
	}

}
----------------
class Account{
	Account(int x){
		System.out.println("account const");
		System.out.println(x);
	}
}
class Deposit extends Account{
	Deposit(){
		super(100);
		System.out.println("Deposit const");
	}
}
public class EncapsulationDemo {
	public static void main(String[] args) {
		Deposit d = new Deposit();
	}
}
Note: If super class having parameterized constructor, programmer must be write one constructor in subclass, and programmer must be write super(---) with paramter in that 
constructor.

Each every class is always hold its own constructor not other class constructor.
	class A{
	    A(){
	    }
	     /*
	    	 B (){//invalid
	     	}
	    */
	}
	class B{
	}

Factory Method:
A method which returns same class object or some other class object is called factory method.
Factory methods are two types
	1.static factory method
	2.non-static factory method

package constructor;


class Parent{
	String parentName = "KrishnaRao";
}
class Child{
	String childName ="RamaChandraRao";
	static Child getChild(){
		return new Child();
	}
	
	Parent getParent(){
		return new Parent();
	}
	
}
public class FactoryMethodDemo {
	public static void main(String[] args) {
		Child child = Child.getChild();
		Parent parent =  child.getParent();
		System.out.println(child);
		System.out.println(child.childName);
		System.out.println(parent);
	System.out.println(parent.parentName);
	}
}


Interface: A java element which provides 100% abstraction is called interface.
	or
If we dont know any implementation then we can go for interface.
      ex: 
	interface I{
		public abstract void m1();
		public abstract void m2();
		public abstract void m3();
	}

Abstract Class: a java element which provides some part of abstraction is called abstract class.
	
if we know some part of implementation then we can go for abstract class.
     ex:
	abstract class AC{
		public abstract void m1();		
		public abstract void m2();
		public  void m3(){
			----------//logic
		}
	}

Class: A java element which provides 100% implementation is called class.
	class Student{
		public  void m1(){
			---------//logic
		}
		public  void m2(){
			---------//logic
		}
		public  void m3(){
			---------//logic
		}
	}

default,
private
public 
protected
abstract
synchronized
final
static
strictfp
native
the above are applied on methods
bellow keywords are not applied on methods.
volatile
transient


parameter: A variable which is available at method paranthesis to hold value is called paramter.

Argument: the value which is send to parameter is called argument.
class A{
	static void m1(int x){
			//x is a parameter
	}
	psvm(-){
		A obj = new A();
		obj.m1(111);//111 is a argument
	}

Varargs:
	Varargs stands for variable argument. 
	It is used to hold zero or one or more values.
	It is introduced in java 1.5 version
	It can be represent with the help of "..." (3dot 		operators)
	Dont use more than 3 dots.
	Dont use lesss 3 dots.
	This 3 dots, we can be called as elipse.
	Dont give any space between dots.

valid syntax:
	String ... x;
invalid syntax: 
	String .   .   .   x;
	String . . . . x;
	String .. x;
	String .     ..x;
	String..     .x;
	String x...;
	...String x;
	
If we are using the arrays, we can not be hold values more than it size;
	int a[] = new int[5];
	
in the above syntax we can assign only 5 values, not more than 5 values.
	
if we are assign less than 5 values, we have memory usage problem.
To overcome above two problems we can go for varargs.

Varargs must be use last parameter of a method, otherwise we will get compile time exception.

public class VarArgsDemo {
	static void m1(int []a){
System.out.println("int array parameter m1 method");
		for(int i=0;i<a.length;i++){
			System.out.println(a[i]);
		}
	}
	static void m2(int ... a){
		System.out.println("----------------");
		System.out.println("m2 method");
		for(int i=0;i<a.length;i++){
			System.out.println(a[i]);
		}
	}
	static void m3(int x, int ...y){
		System.out.println("-------------");
		System.out.println(x);
		System.out.println("-------------");
		for(int i=0;i<y.length;i++){
			System.out.println(y[i]);
		}
	}
	/*static void m1(int...a){
		
	}*/
	static void m1(int a){
		System.out.println("int prameter m1 method");
		System.out.println(a);
	}
	
	/*static void m4(int...a,int x){
		
	}*/
	/*static void m5(int a,int...b,int c){
		
	}*/
	static void m1(){
		System.out.println(" zero argument m1 method");
	}
	public static void main(String[] args) {
		m1();
		m1(100);
		//m1(200)
		m1(new int[]{11,22,33});
		m2();
		m2(111);
		m2(222,333);
		m2(444,555,666,777,888,999);
		m3(2323);
		m3(444,555);
		m3(666,777,888);
		//m4();
		//m4(111);
		m4(111,222);
	}

}

Interface:
	If we dont know any implementation or If we want to provide 100% abstraction then we can go for  
interface.
	Interface is the communication channel between service provider and service consumer.
	Interface is the combination of public static final varaibles and public abstract methods.
	If we want to develop interface concept in java, we need to use one predefine keyword that is "interface". This is always followed by Interface_Name.
	the naming conventions of interface is same as Class_Name.
	All the variables are of interface must be initialized, otherwise we will get compiletime error.
	By default all the variables are public static final.
	By default all the methods are public abstract.
	static and abstract are invalid combination.
	final and abstract are invalid combination. Interface provides commonality, forcebility.
	If any class,abstrct class want to communicate with interface we need one special keyword that is "implements" keyword.
	We can write "abstract" keyword infront of inteface keyword.
interface I{
	int i=111;
	void m1();
}
javac I.java
javap I
interface I{
	public static final int a =111;
	public abstract void m1();
}
interface I{
	int i=111;
	final abstract void m1();//invalid
	static abstract void m2();//invalid
}
Based on, the methods of interface can be classfied as an three types from java 1.8 onwards.
	a.Marker interface
	b.Functional interface
	c.Normal interface.
	
Marker interface: 
	An interface which doesnot have any method is called marker interface.
	ex: java.io.Serializable, java.lang.Cloneable, java.util.RandomAccess.
	If any class, which implements 
 that class must be provide implementation for all the methods of interface. it is comes under forcebility.
	
	If any class, which implements markerinterface that class is treated as a special class by the jvm.
		
FunctionalInterface: 
	An interface, which contains only one method is called Functionalinterface.
	If we want to mention our interface as an functionalinterface, we should use one java 1.8 feature, that @FunctionalInterface annotaion.
	ex: 
	@FunctionalInterface
	interface I{
		public abstract void m1();
	}
	
Normal interface: An interface which contains more than one method or only one method without @FunctionalInterface annotation is called normal interface. 
	interface I{
		public abstract void m1();
		public abstract void m2();		
	}

	interface J{
		public abstract void m1();
	}

Note: we cannot create object for interface, but we can create reference. With the help of reference, we can hold its implementation class.
	
	interface J{
		public abstract void m1();
	}
	class M implements J {
	}
here M is called implementation class.	

we can write abstract keyword infront of interface keyword.
we can not write static and non-static blocks and constructors.

	interface J{
		static{//invalid
		}
		{         // invalid
		}
	}


	interface K{
		K(){//invalid
		}
	}

There is no super class for interface.
If we are trying to write concrete methods in java we are getting compile time error.



package interfaces;

interface I {      //extends java.lang.Object{
	int a=111;
	public abstract void m1();
	void m2();
	/*void m3(){
		System.out.println("concrete methods");
	}
	{
		System.out.println("non-static block");
	}
	static{
		System.out.println("static block");
	}
	I(){
		System.out.println("constructor");
	}*/
}
class J implements I{
	public void m1(){
		System.out.println("J class m1 method");
	}
	public void m2(){
		System.out.println("J class m2 method");
 	}
}

public class InterfaceDemo {

	public static void main(String[] args) {
		//I obj = new I();
		/*I obj ;
		obj = new J();*/
		
		I obj = new J();
		obj.m1();//synatax (1)
		obj.m2();//synatax (2)
	}

}
In above program syntax--1 compiler first check the type of obj,here type of obj is interface I. so first compiler will goes to I and check whether m1 method is avilable or not, if not compile time error, if yes m1() will bind to obj. 
Then jvm will having the capability to check value.
Jvm checks value, here value is J class memory(new J()).
So jvm executes the m1 method from J class.
Syntax--2 execution is also same as syntax---1.

abstract class:
	If we want to proivde some part of implemention or some part of abstraction then we can go for abstract class.
	In the abstract class we can write both abstract and concrete method.
	Class should be mention with "abstract" keyword.

	Abstract class provides both forcebility and reusebility. 
	ex: 
	abstract class AC{
		abstract void m1();
		void m2(){
		}
	}
We can not create object for abstract class
	AC obj = new AC();//invalid syntax:	But we can create reference.
		AC obj;
With the help of abstract class reference, we can hold sub class implementation logic/memory.
If we want use functionalities of interface we need implementation class, in same manner if we want use the abstract class funcationalities we need sub class.
	The class which is extends abstract class is called sub class.
	ex:
		class SAC extends AC{
			void m1(){
			}
			void m2(){
			}
		}
Note: if any class which implements interface or extends abstract class, we should provide the body for all the method of interface and abstract class in implementation or sub class.
	Interface I{
		public abstract void m1();
		public abstract void m2();
	}		
	abstract class AC implements I{
		public  void m1(){}
		public abstract void m2();
		abstract void m3();
	}

	class SAC extends AC implements I{
		public void m1(){
		}
		public void m2(){
		}
		void m3(){
		}
	}

With in the abstract class we can write constructors.
with in the abstract class we can write both static and non-static blocks.
	abstract class AC{
		AC(){
			S.o.p("constructor");
		}
		{
			S.o.p("non-static block");
		}
		static{
			S.o.p("static block");
		}
	}
abstract class is also subclass of java.lang.Object class.
abstract class AC{
}
javac AC.java
after compilation compiler will convert inthe following manner.

javap AC

abstract class AC extends java.lang.Object{
	AC(){
		super();
	}
}






Q)Why abstract class have constructor, whynot interface?
interface doesnot need any predefine functionalities from java.lang.Object class, so need of forward the controle from interface to Object class.
If we are not forwarding the controle no need of constructor.

but where as abstract class need some predefine functionalaties of Object class, so we need to forward our contole from abstract class to Object class. If we want to forward controle from abstract class to Object class we need "super()". 
This "super()" must be write in the constructor.
so for farwarding the controle purpose we need constructor in abstract class.

Q) why abstract class have static block why not interface?
A)All the variables of interface by default static final, so if we want to declare static final varaibles in interface level we need to initialize the static variables first. So already static variables are intitialized by the programmer, so no need of using the static block again in interface.
	But where as static variables in abstract class may or may not be initialized. If not initalized, we can use static block for static variables initialization purpose.

Q) Why abstract class have non-static block why not interface?
A)non-static blocks are used to initialize the non-static variables. But in interface every variable is static so no need of non-static block.
whereas in abstract class either we can write static and non-static variable, so if we want initilize the non-static variable, so we need non-static block.
Q) difference between interface and abstract class?
Interface:

1.If we dont know any implementation then we can go for interface.

2. Interface provides 100% abstraction.

3. we can not write protected, final,static, private,strictfp,native methods.

4. Every variable must public static final variables.

5. Interface variables doesnot have private,protected ,transient,volatile keywords.
6.Interface variables must be initialize.

7. In the interface we can not write static,non-static blocks and constructors.
8. No super class for interfaces.
abstractclass:
1. If we know some part of implementation then we go for abstract class.
2. abstract class provides some part(percentage) of abstraction based on abstract methods.
3.we can write any type of method.
4. No need of public static final variable, if we want we can write.
5. we can write private,protected,transient,volatile keyword before variable names.
6. no need of initialization
7.we can write static,non-static blocks and constructor.
8. abstract class is the sub class of java.lang.Object.
	
static block usage:
           To initialize the static variables.
           To registering the Driver class with DriverManager.
           To provide common information .

	
Note: Abstract class no need of having abstract methods.
	abstract keyword is used to represent the non-body methods.
	abstract keyword is used to provides some restrictions to end user to create an object for class.

	abstract class AC{
		void m1(){
		}
		void m2(){
		}
	}
If we want to use functionalities of abstract class we need subclass.

if any class which is not implements all the abstract methods of interface, we should be mention that class as an abstract class.

	interface I{
		public abstract void m1();
		public abstract void m2();
	}
Invalid syntax:		
	class A implements I{     
		public void m2(){
		}
	}

valied syntax:
	abstract class A implements I{     
		public void m2(){
		}
		public abstract void m1();
	}
******************************************
abstract class  MM extends java.lang.Object{
	MM(){
	    super();
	    System.out.println("MM class constructor");
	}
	void m1(){
	    System.out.println("MM class m1 method");
	}
	void m2() {
	    System.out.println("MM class m2 method");
	}
	abstract void m3();
}
class NN extends MM{
	NN(){
		super();
		System.out.println("NN constructor");
	}
	void m3(){
	         System.out.println("NN class m3 method");
	}
}
public class AbstractDemo {
	public static void main(String[] args) {
		//MM obj = new MM();
		MM obj;
		obj = new NN();
		obj.m1();
		obj.m2();
		obj.m3();
	}
}


Note: 
Relation between object and constructor:

when ever we create object with the help of new keywrod, we can execute the constructor.
Without object cretion we can execute the constructor in abstract class.
Object is created but not constructor is executed.
ex: clone(), deserialization.
-----------------------------------------------------
interface MM{
	void m1();//public abstract void m1();
	void m2();//public abstract void m2();
	void m3();//public abstract void m3();
}
abstract class NN implements MM{
	public void m1(){
   	    System.out.println("NN class m1 method");
	}
	public void m2(){
	    System.out.println("NN class m2 method");
	}
} 
class OO extends NN{
	public void m3(){
	    System.out.println("OO class m3 method");
	}
}
public class AbstractDemo {
	public static void main(String[] args) {
		OO obj = new OO();
		obj.m1();
		obj.m2();
		obj.m3();
	}
}

if any class which is not implements all the abstract methods of interface, we should be mention that class as an abstract class.

final means nobody inherit the functionalities.
By default constructors are not inherit, so declare constructor as final meaning less.

and we cannot declare constructor as static.
static means class data, but constructor is purely related to object.

and we cannot mention constructor as abstract, for this we have two reasons
the reason is when ever we create an object constructor automatically called so constructor must be have the body.
and also abstract means no body we should be use inheritance for providing body, but constructors are not participated in inheritance.

Inheritance:
	Extracing the functionalities from one class to another class is called inheritance without creating object.

Without inheritance we need to face following problems.
	1. Duplicate code/boilerplate of code.
	2. Size of the code will be increasing
	3. Compilation time will be increases.
	4. Low performance
To avoiding above problems java uses one of the  object oriented programming system priciple that is "INHERITANCE".
	

In java we have 5 types inheritances.
	a.  Single Level Inheritance:
	==================
	Extending the functionalities from java.lang.Object class is called single level inheritance.
		
	class A  extends java.lang.Object{

	}

	b.Multilevel inheritance:
	================
	Extends the functionalities from  other than java.lan g.Object class is called mutltilevel inheritance.

	class A{

	}

	class B extends A{

	}

Note: Every class is the subclass of java.lang.Object either directly or indirectly.

	Hierarchal inheritance:
	===============
Derived the one class functionalities into more than one subclass is cjlled hierarchal inheritance.
class A{}
class B extends A{}
class C extends A{}
	Multiple inheritance:
	==============
Extracting the functionalites from more than one super class to only one subclass is called multiple inheritance.
	Java does not support multiple inheritance through classes. The reason is ambiguious problem.	
	class A{
	}
	class B{
	}
	class C extends A,B{

	}

After extends keyword we can not write more than one class name.

	Hybrid Inheritance:
	=============
Combination of all the inheritance is called hybrid inheritance.In hybrid inheritance also, we have multiple inheritance, so we can not implements hybrid inheritance in java.

SingleLevel + MultiLevel
SingleLevel+Hierarchal
SingleLevel+Hierarchal+MultiLevel
The above three combinations are comes under Hybrid. These type of combinations are, we can implement in java.
But if we add multiple inheritance to above combinations, then we cannot implement.

Note: We can achieve multiple inheritance through interfaces. (only for methods not for variables).

We can develop inheritance with the help of two keywords.
	a.extends
	b.implements
"extends" can be used in the following scenarios 	relation between
	    a.class to class
	    b.abstract class to abstract class
 	    c.interface to interface
	    d.class to abstract class
	    e.abstract class to class
"implements" can be used in the following scenarios.......
	relation between
		a.class to interface
		b.abstract class to interface
class A{
	int a = 10;
	A(){
	    super();
	    System.out.println("A class constructor");
	}
}
class B extends A{
	B(){
	   super();
	   System.out.println("B class constructor");
	}
	int b = 20;
}
public class InheritanceDemo {
	public static void main(String[] args) {
		B obj = new B();
		System.out.println(obj.a);
		System.out.println(obj.b);
	}

}

abstract class to class.


class A{
	void m1(){
		System.out.println("A m1()");
	}
}
abstract class B extends A{
	abstract void m2();
} 
class C extends B{
	void m2(){
		System.out.println("C m2() ");
	}
}
public class AbstractDemo1 {
	public static void main(String[] args) {
		C obj = new C();
		obj.m1();
		obj.m2();
	}
}



Note: If super class having parameterized constructor, in sub class programmer must be write one constructor, in that constructor we need to write one super(--) with matching argument syntax.

	package inheritance;


class A{
	A(int x){
		System.out.println("A class constructor");
	}
}
class B extends A{
	B(){
		super(100);
		System.out.println("B class constructor");
	}
}
public class InheritanceDemo {

	public static void main(String[] args) {
		B obj = new B();
		System.out.println(obj);
	}

}

Note: When ever Sub class is loading from secondary memory to primary memory.......
first super class static variable and static block will be loaded after that sub class static variable and static blocks will be loaded.

When we create subclass object, then first super class non-static variables, non-static block, constructors are loaded after that sub class non-static variables, non-static blocks, constructors are loaded after that jvm will provides memory for subclass only.

class A{
	static int a = m1();
	static int m1(){
	System.out.println(a);
System.out.println("super class  static m1 method");
	return 111;
	}
	static{
	System.out.println("super class static block");
	}
	int b = m2();
	int m2(){
		System.out.println("------------");
		System.out.println(b);
System.out.println("super class non-static m2 method");
		return 222;
	}
	{
            System.out.println("super class non-static block");
	}
	A(){
                   System.out.println("super class constructor");
	}
}
class B extends A{
	static int c = m3();
	static int m3(){
		System.out.println("-----------------");
		System.out.println(c);
            System.out.println("sub class static m3 method");
		return 333;
	}
	static{
	System.out.println("sub class static block");
	}
	int d = m4();
	int m4(){
		System.out.println("--------------------");
		System.out.println(d);
        System.out.println("sub class non-static m4 method");
		return 444;
	}
	B(){
	System.out.println("sub class constructor");
	}
	{
	System.out.println("sub non-static block");
	}
}
public class InheritanceDemo {
	public static void main(String[] args) {
		B obj = new B();
		System.out.println(obj);
	}
}

Note: When ever we create object for sub class jvm only allocate the memory for subclass not for its super class.
class A{
	A(){
	System.out.println("super class constructor");
	}
}
class B extends A{
	B(){
	System.out.println("sub class constructor");
	System.out.println(this.hashCode() 			+"..."+super.hashCode());
	System.out.println(this.getClass().getNam() 		+"..."+super.getClass().getName());
	}
}
public class InheritanceDemo {
	public static void main(String[] args)throws 			InterruptedException {
		B obj= new B();
		Thread.sleep(365*1000*24*7);
		System.out.println("*************");
	}

}
JavaVisualVM:
-----------------
	It is a tool, which comming to our system mean while java software installation.
	It is available in C:\Program Files\Java\Jdk\bin\jvisualvm.
	With the help of this tool, we can recognize the number of instances created by jvm.
	Meanwhile of working with this jvisualvm tool our program must be in the running mode.
	
Steps to working Jvisualvm tool:
	1. Go to C:\Program Files\Java\Jdk\bin folder.
	2. search jvisualvm tool.
	3. double click on jvisualvm
Note: program must be in running mode.
	4. In the leftside of tool, select our present 	running program.
	5. right click on our program
	6. click on open
	7. click on monitor
	8. click on heapdump
	9. click on classes
	10. search our program(type our package name in 	the botom of jvisualvm tool search box)

Example on multilevel and hierarchal inheritance:
class A{
	int a = 111;
}
class B extends A{
	int b = 222;
}
class C extends B{
	int c = 333;
}
class D extends A{
	int d = 444;
}
public class InheritanceDemo {
	public static void main(String[] args){
		C obj= new C();
		System.out.println(obj.a);
		System.out.println(obj.b);
		System.out.println(obj.c);
		D obj1 = new D();
		System.out.println(obj1.d);;
		System.out.println(obj1.a);
	}
}

ex: 
class MM{
}
class NN extends MM{
}
create object for subclass:
	If we create object for subclass both sub and super class data can be access. 
	NN obj = new NN();

	If we create an object for superclass only superclass data type can be access.

Upcasting or generalization or widening:
	placing sub class memory into super reference is called upcasting.
	MM obj = new NN();
	In the upcasting procedure, static varaible,non-static variable,static method are executed from reference type(super class and its super class).
Only non-static method are executed from memory(new NN()--subclass and its super clas).		
class MM{
	static int a = 111;
	int b = 222;
	static void m3(){
		System.out.println("MM m3 method");
	}
	void m4(){
		System.out.println("NN m4 method");
	}
	void m1(){
		System.out.println("MM m1 method");
	}
}
class NN extends MM{
	static int a = 333;
	int b = 444;
	static void m3(){
		System.out.println("NN m3 method");
	}
	void m4(){
		System.out.println("NN m4 method");
	}
	void m2(){
		System.out.println("NN m2 method");
	}
}
public class InheritanceDemo {
	public static void main(String[] args){
		NN obj = new NN();
		obj.m1();
		obj.m2();
		System.out.println("-----------");
		MM obj1 = new MM();
		obj1.m1();
		System.out.println("------------");
		MM obj2 = new NN();//upcasting
		System.out.println(obj2.a);
		System.out.println(obj2.b);
		obj2.m3();
		obj2.m4();
		//NN obj3 = new MM();
		System.out.println("--------");
		NN obj4 = (NN)obj2;
		System.out.println(obj4.a);
		System.out.println(obj4.b);
		obj4.m3();
		obj4.m4();
	}

}
		
Downcasting or specialization or narrowing:
	Converting super class memory(subclass) into sub class type is called  downcasting.
	If we want do the downcasting first we need to upcasting.
	MM obj = new NN();//upcasting
	NN obj1 =(NN)obj;//downcasting.

In java we have three types of relations.
1.Is-A relation
2.Has-A relation
3.Uses-A relation.

Is-A:
 Accessing all functionalaties from one class to another class, then we can go fro Is-a relation.

In java we can develop is a relation with the help of extends keyword.

	class MM{}
	class NN extends MM{}

In the above relation we have a small drawback. That is if super class having 1000 variables, if we want to use some part of data(variables), then Is-a is not a best choice, the reason unnecessarly wasting of memory.
	
To avoid this drawback we can go for has-a relation.

Has-a:
	creating one class object within the another class is called has-a relation
	class MM{}
	class NN{
		psvm(){
		MM obj = new MM();
		}
	}
uses-a: using one class reference in another class as a method parameter is called uses-a relation.
	this concept is comes under  call by reference.
If we want use same memory data with in the different location(method), then we need to forward that memory into  different location(method) as argument.
	
Polymorphisam:
Polymorphisam is one of the oops principle.
it is a mechanisam to do same action with in the different forms.
Polymorphisam terminology comes from greek language.
poly means many and morphs means forms.
polymorphisam means manyforms.
polymorhisam can clasified into two types
a. Static polymorphisam or Compiletime polymorphisam.
b. Dynamic polymorphisam or Runtime polymorphisam.
polymorphisam can be achieved through two techniues.
	a. method overloading.
	b. method overriding.
MethodOverloading:
	Writing the same method with different parameters(Number of, type of , place of) with in the same class is called method overloading.
	We can not write same method with same parameters with in the same class.
	We should be differentiate one method to another method with the help of parameters.

Note: dont consider variables names and return types.	
1. Number of parameters.
2. Type of parameters.
3. Place of parameters.
Invalid syntax:
class A{
	void m1(){
	}
	void m1(){//duplicate methods
	}	
}
Valid syntax: 
	class A{
		void m1(){
		}
		void m1(int x){
		}
		void m1(String x){
		}
		void m1(int x, String y){
		}
		void m1(String y, int x){
		}
	}
Example program on MethodOverloading:


public class MethodOverloadingDemo {
	void m1(){
System.out.println("m1 method with zero argument");
	}
	void m1(int x){
System.out.println("m1 method with int argument");
		System.out.println(x);
	}
	void m1(String x){
System.out.println("m1 method with string argument");
		System.out.println(x);
	}
	void m1(int x, float y){
System.out.println("m1 method int-float argument");
		System.out.println(x);
		System.out.println(y);
	}
	void m1(float y, int x){
System.out.println("m1 method float-int argument");
		System.out.println(y);
		System.out.println(x);
	}
	public static void main(String[] args) {
MethodOverloadingDemo md = new 						   MethodOverloadingDemo();
		md.m1();
		md.m1(234);
		md.m1("suji");
		//md.m1(10,20);
		md.m1(10,23.34f);
		md.m1(23.33f,10);
	}
}

MethodOverriding:
	What ever the logic, which is given by the java software or existed method is not suitable for our project requirement, then we should write our own logic within the existed method is called MethodOverriding.
	
MethodOverriding must be follows the following rules:
	
1) AccessModifier of a method in subclass must be same or increasable.
super class ---default method
sub class ---default,protected,public.

super class --- protected method
sub class    --- protected,public

super class---public method
sub class   ---public

2) Method return type must be same.
3) Method name must be same.
4) Number of parameters, type of parameters and place of parameters must be same.
5) throws clause exception class name can be same or we can delete throws clause or we can use throws clause with lower class(subclass) exception. But we cannot increase the exception level(superclass).

Note: MethodOverriding must be dependupon inheritance.
Varaible name is not consider in the concept of methodoverloading and methodoverriding

package inherit-nce;

import java.io.FileNotFoundException;
import java.io.IOException;

class L{
	void m1(){
		
	}
	void m2(int x, float y){
		
	}
	void m3() throws IOException{
		
	}
	
}
class M extends L{
	/*@Override
	void m3()throws IOException{
		
	}*/
	/* @Override
	 * void m3(){
		
	}*/
	
	/*@Override
	 void m3() throws FileNotFoundException{
		
	}*/
	/*@Override
	void m3()throws Exception{ //not override method
		
	}*/
	
	
	/*@Override
	 * void m1(){
		
	}*/
	/*@Override
	 * protected void m1(){
		
	}*/
	/*@Override
	public void m1(){
		
	}*/
	/*@Override
	public int m1(){//not override method
		return 100;
	}*/
	/*@Override
	public void m2(){
		
	}*/
	/*@Override
	void m2(int x){//not override method
		
	}*/
	/*@Override
	void m2(int x, int y){ //not override method
		
	}*/
	/*@Override
	void m2(float x, int y){//not override method
		
	}*/
}
public class MethodOverridingDemo {

	public static void main(String[] args) {

	}

}

Note: private, static, final methods are not partispated in the method overridng concept.

class M {
  private void m1(){
     System.out.println("M class m1 method");
   }
  static void m2(){
     System.out.println("M class m2 method");
  }
   final void m3(){
     System.out.println("M class m3 method");
   }
}
public class MethodOverridingDemo extends M {
/*@Override
private void m1(){
System.out.println("MethodOverridingDemo class m1 							method");
}*/
/*@Override
	static void m2(){
System.out.println("MethodOverridingDemo class m2 					method");
}*/
	
/*final void m3(){
System.out.println("MethodOverridingDemo class m3 					method");
}*/
public static void main(String[] args) {
MethodOverridingDemo md 	      = new MethodOverridingDemo();
        //md.m1();
        // md.m2();
	}
}
If we are not using @Override annotaion both private and static method are looks like partispated in methodoverriding but they are not really partispated in methodoverriding.


Static polymorphisam:(Early binding)
A method which is bind by the compiler at compilation time, the same method is executed by the jvm at run time is called compile time polymorphisam or static polymorphisam. 

Dynamic polymorphisam:(lazy binding)
A method which is bind by the compiler at compilation time, the same method is not executed by the jvm at run time is called dynamic polymorphisam or run time polymorphisam or lazy binding.

class MM{
	void m1(){
	 System.out.println("MM m1 method");
	}
	void m2(){
	 System.out.println("MM m2 method");
	}
	static void m3(){
	 System.out.println("MM m3 method");
	}
}
class NN extends MM{
	void m2(){
	 System.out.println("NN m2 method");
	}
	static void m3(){
  	 System.out.println("NN m3 method");
	}
}
public class Polymorphisam {
	public static void main(String[] args) {
		NN obj = new NN();
		obj.m1();
		obj.m2();
	System.out.println("-------------");
	MM obj1 = new NN();//upcasting
		obj1.m1();//CTP
		obj1.m2();//RTP
		obj1.m3();//CTP
	}
}
Method Hidding: 
Super class static method, which is hidding the execution of sub class static method is called method hidding.

Jvm is always give the prefarence to subclass memory(new NN()). 
If it is non-static method then jvm is executing from subclass, so there is no method hidding.
But if it is static method then jvm is not executing from subclass, it is executing from super class is called method hidding.

In the above class non-static m2 method is comes under method overriding, static m1 method is comes under method hidding.

Co-Varient return types:
	This functionality introduced in java 1.5 version.
	In the method overriding concept the method return type must be same upto java 1.4.
	But from java 1.5 onwards we can write subclass override method return type can be subclass of superclass method return type.

Note: Return type must be referenced type(non-primitive).
ex:  
	class A{
		A m1(){
			new A();
		}
	}
	class B extends A{
		B m1(){//co-varient method
			return new B();
		}
	}

is-a
has-a
uses-a
downcasting notes
static-abstract
interface vs abstract class
staic vs new



















String Handling:
	String is a collection of characters with in the double quotes.
	Based on the character we can classify String into three types.
1)	Numerical String
2)	Character String
3)	Special character String.
	Numerical String: If we are placing digits within the double quotes 
 is called Numerical String.
		Ex:  String s = “123”;
	Character String: If we are placing character with in the double quotes is called Character String.
			Ex: String s = “jagadesh”;
Special Characters String: if we are placing any special characters with in the double quotes is called Special Character String.
			Ex: String s = “$%^&*”
		From above information whatever the character we are writing within the double quotes that are comes under String.
We can write one or more character or combination of characters.
(Digit, characters, special characters) within the double quotes.
	String s = “R”;
	String s = “123abce%^&*”;
Java introducing String is an predefine class, which is available in java.lang package.
We can use String as a data type also.
Objects are classified into two types.
1)	Immutable
2)	Mutable.
Immutable Objects:  The value of an object has not changeable within the same memory; instead of changing it creates new object is called immutable.
	Ex: All Wrapper classes (Byte, Short, Integer, Long, Float, Double, Character, Boolean), java.lang.String .
Mutable:  The value of an Object has been changed with in the memory is called mutable object.
	Ex: java.lang.StringBuffer, java.lang. StringBuilder

If we want to check any two object in java we following ways.
1)	By using  “==” operator
2)	By using equals().
1)	“==” operator is always checks hashCode of an objects.
2)	equals() of java.lang.Object class is also checks hashCode of an objects.

If we want to checks the content of objects then we can go for override the method within the String class. Java software developer has already override equals() in java.lang.String class. 
The equals() of String class, is going to be check the content of an object.
In the java.lang.StringBuffer  class equals() is not override.

Difference between 
1)	String s = “ram”    and
2)	String s1 = new String(“ram”);
In the first statement JVM will create only one object in String Constant Pool area.
In the second statement JVM will create two objects.
a)	One is in Heap Area
b)	Second is in String Constant Pool.
In the second statement reference (s1) is always points Heap Area object only.
Before creating object in String Constant Pool, JVM checks is there any object existed with “ram” content or not if not then it will create “ram” in SCP also. If object is existed JVM won’t create any object in SCP, using the existed object only.
If any object is not having any external reference, those objects are easily garbage (de-allocate).
But in SCP object some time don’t have any external reference, these are not garbage.
The objects which are available in SCP are strong objects.
String Constant Pool:
	If we want to use the same objects repeated times, then place those 
objects  within the SCP only.
	With the help of SCP we will get bellow advantages.
1)	Memory utilization
2)	Performance increase.

All the objects having same content then JVM is not create new object, JVM uses existed object memory only. 
If anyone objects is doing updating, that updated (new) value is not affected to remaining objects, that updated value effected to only one object.
That JVM is not change the content of existed memory; instead it will create new memory with updated value.
SCP objects are very strong objects.
For each and every string we have memory in SCP.

intern (): If we want interact with the SCP data, then we have one method that intern().
	




public class StringDemo {

	public static void main(String[] args) {
String s1 = "ram";
		String s2 = new String("ram");
		System.out.println(s1==s2);
		System.out.println(s1.equals(s2));

		String s1 = "ram";
		String s2 = "ram123";
		s1.concat("123");
		System.out.println(s1);
		s1=s1.concat("123");
		System.out.println(s1);
		System.out.println(s1==s2);
		s1="ram"+"123";
		System.out.println(s1==s2);

String s1 = "ram123";
		String s2 = new String("ram");
		System.out.println(s1==s2);
		s2.concat("123");
		System.out.println(s2);
		s2=s2.concat("123");
		System.out.println(s2);
		System.out.println(s1==s2);
		s2="ram"+"123";
		System.out.println(s2==s1);
		String s1 = "CoreJava";
		String s2 = new String("AdvancedJava");
		String s3 = "AdvancedJava";
		String s4 = s2.intern();
		System.out.println(s3==s4);
String s1 = "corejava";
		String s2 = "COREJAVA";
		String s3 = s1.toUpperCase();
		System.out.println(s2==s3);
		String s4 = s3.toUpperCase();
		System.out.println(s3==s4);
		System.out.println(s2==s4);
String s1 = "ram";
		String s2 = "Ram";
		System.out.println(s1==s2);
		System.out.println(s1.equals(s2));
		System.out.println(s1.equalsIgnoreCase(s2));
	String s1 = new String ("java is an oopl");
		String s2 = new String ("java is an oopl");
		System.out.println(s1==s2);
		String s3 = "java is an oopl";
		System.out.println(s1==s3);
		String s4 = "java is an oopl";
		System.out.println(s3==s4);
		String s5 = "java is "+"an oopl";
		System.out.println(s4==s5);
		String s6 = "java is ";
		String s7 = s6+"an oopl";
		System.out.println(s4==s7);
		final String s8 = "java is ";
		String s9 = s8+"an oopl";
		System.out.println(s4==s9);
	}
}

Note: If we are doing modification on string by using reference(either SCP reference or heap area reference) new object will be created in the heap area.
	String s1 = “ram”
	S1.concat(“123”);(new object is available in heap area)
	If we are doing modification on string by using content then new object will be created in the SCP.
	S1=”ram”+”123”;(new object  is created in the scp).
Note: With the help of intern() we can interact with unreferenced  SCP data.






public class StringDemo { //extends String {
	public static void main(String[] args) {
		String s = "internationalization";
		System.out.println(s.length());
		String s1="A";
		String s2 = "a";
		System.out.println(s1.compareTo(s2));
		System.out.println(s2.compareTo(s1));
		
		StringBuffer sb1 = new StringBuffer("a");
		
		StringBuffer sb2 = new StringBuffer("b");
		//System.out.println(sb1.compareTo(sb2));
		s=s.concat("--->java");
		System.out.println(s);
		System.out.println(s1.equals(s2));
		System.out.println(s.startsWith("inter"));
		System.out.println(s.endsWith("inter"));
		System.out.println(s1.equalsIgnoreCase(s2));
		byte b[] = s1.getBytes();
		System.out.println(b[0]);
		int i = 100;
		int j = 200;
		String s3 = String.valueOf(i);
		String s4 = String.valueOf(j);
		String s5 = String.valueOf('d');
		System.out.println(i+j);
		System.out.println(s3+s4+s5);
		System.out.println(s.lastIndexOf("n"));
		System.out.println(s.lastIndexOf("nation"));
		System.out.println(s.indexOf('t'));
		System.out.println(s.indexOf('n'));
		String s6 = "he";
		System.out.println(s6.replace('e', 'i'));
		System.out.println(s.replaceAll("nation", "india"));
		String s7 = "java is an oopl";
		String s8[] = s7.split(" ");
		for(String s9: s8){
			System.out.println(s9);
		}
		String s10 = "10,20,30,40,50";
		int total = 0;
		String s11[] = s10.split(",");
		for(String s12: s11){
			System.out.println(s12);
			total = total+Integer.parseInt(s12);
		}
		System.out.println(total);
		
		//we cannot convert string value to character value
		//we dont have Character.parseChar().
	}
}
Difference between String and StringBuilder and StringBuffer
String:
======
Immutable
Java 1.0
Not synchnoized
Concat()
compareTo()
Not ThreadSafe
Higher performance
Not good at result
Implements java.lang.Comparable
No reverse()
No capacity()
StringBuffer
=========
mutable
Java 1.0
synchnoized
append
NO compareTo()
ThreadSafe
low performance
good at result
not Implements java.lang.Comparable
reverse()
capacity()
StringBuilder:
==========
mutable
Java 1.5
Not synchnoized
append
NO compareTo()
Not ThreadSafe
Higher performance
Not good at result
Not Implements java.lang.Comparable
reverse()
capacity()


public class StringHandling {
	public static void main(String[] args) {
		String s = "ram";
		String s1 = new String();
		System.out.println(s);
		System.out.println(s1);
		String s2 = new String("ramchandra");
		System.out.println(s2);
		String s3 = new String("");
		System.out.println(s3+"***");
		byte b[] = {65,66,67,68,69,70,71,72};
		String s4 = new String(b);
		System.out.println(s4);
		String s5 = new String(b,2,4);
		System.out.println(s5);
		char c[] = {'a','b','c','d','e','f'};
		String s6 = new String(c);
		System.out.println(s6);
		String s7 = new String(c,1,3);
		System.out.println(s7);
		StringBuffer sb  = new StringBuffer("standard");
		String s8 = new String(sb);
		System.out.println(s8);
		StringBuilder sb1 = new StringBuilder("Edition");
		String s9 = new String(sb1);
		System.out.println(s9);
		
	}

}
Note: If we want to use the compareTo() , both objects must be homogeneous and both objects must be implements java.lang.Comparable.
JVM ARCHITECTURE:
-----------------------

Virtual Machine:
	VM is an software/Application which will provide environment or memeory areas for executing the programs.

JVM: JVM is an software/application which will provide environment or five individual identical memeory areas
for executing the java programs.

We have two types of JVM

	1) Client JVM
	2) Server JVM.

JVM is only provides abstraction. 
JRE is provides implementation for that abstraction.
We have different jvm's for different os.
That means we have different JRE software for different Operating Systems.

	If we want to execute the java program, first we should interact with the jvm. 
With the help of "java" command we communicate with JVM. "java" keyword is always followed by class_name.
	syntax: java Class_Name

Java is internally communicate the with JVM, then JVM will come into the picture, first JVM will read class_name and JVM controle will goto to secondary memory, that class bytecode will be loaded from secondary memory to primary memory.

	JVM internally uses ClassLoaderSubSystem to load the .class files from secondary memory to primary memory.

In the ClassLoaderSubSystem, we have three separate phases. Those are
	1)Loading phase.
	2)Linking phase.
	3)Initialization phase.

LoadingPhase: In this phase the bytecode(predefine and user define class) will be loaded from secondary memory to primary with the help of bellow classloaders.
In this phase we have three ClassLoaderSubSystems.
		1. ApplicationClassLoaderSubSystem
		2. ExtensiveClassLoaderSubSystem
		3. BootstrapClassLoaderSubSystem.

ApplicationClassLoaderSubSystem:
	It will loads userdefine class files from current directly and environment variable path.
	
ExtensiveClassLoaderSubSystem:
	It will loads predefine class files from jre\lib\ext folder.

BootstrapClassLoaderSubSystem:
	It will load predefine class files from jre\lib\rt.jar file.

	In the above three phases class is not available, then we will get one error cannot find or load main class <class_name>.

	If available that .class file will loaded from secondary memory to primary memory and handover to linking phase.
	
Linking: 	
	In this phase the loaded bytecode will be checked by verifier.
	
In this phase we have three components.
	1.Verifier
	2.Preparer
	3.Resolver.

Verifier will check whether the bytecode is properly organized or not, is there any virus and hacking code or not. If yes verifier will give verifier error, if no that bytecode will be handover to preparer.

Preparer will provide the default values to static variables in loading phase.

Resolver: it will convert symbolic reference  into original references.

After this phase code will be handover to initializer.

Initialization: all default values of static data will be replaced with original or actual data.

RuntimeMemoryAreas's:
	jvm provides 5 runtime memory areas.

	1) Method Area
	2) Heap Area
	3) Java Stack Area
	4) PC Registers
	5) Native Method Area

MethodArea: In this area all class data is stored. that means all the static  data is available in the method area.
Heap Area: in this area all object data is stored. that means all the non-static data is available in heap area.
	All the objects are created in the heap area only.
JavaStackArea: Every thread have its own stack.
	These stack will be interact with local data/method level data. Javastack have different slots, those slots are called stackframes.
JavaStackFrame will convert into three parts.

1) Local Variable Storage Area:
	In this all local variables are stored.
2) Operand Stack: 
	in this phase all operations and calculations will be happens.
3) FrameData: 
	If method contains any exceptions, those exceptions will be thrown by frame data only.

PC Registers:
	Every thread have its own PC Registers, these registers will hold the next execution statements address.

Native method area:
	If java wants communicate with c and c++ code, those code will be available in Native method area.

	If we interact with c and c++ code, we need libraries, those will be given by NativeLibrary, that library will be handover by NativeMethodInterface to executable engine.
ExcutionEngine:
	Internally jvm uses two translators to convert bytecode to  executable code.
	1. Interpreter
	2. JIT Compiler
Interpreter is good at execute the single time execution statements.
JIT compiler is good at execute the looping statements.
But these two are unable to findout behaviour of an statements.
In this one special component come into picture that is "profiler"

First profiler will identify the whether statements are single time or looping statements.
If single time execution statement then those statements handover to interpreter otherwise handover to JIT compiler.
Java is an high performanced language, the reason java internally uses two translators to covert our bytecode to executable. So java application are executed with in the less time. If the application executed within the lesstime automatically the performanced will increasers.

In this executable engine we have some other special components, those are Garbage  Collecter and Security manager.
		
Wrapper classes:
	Representing the primitive data in the format of object is called wrapperclass.
	
	Wrapper class are wraps the primitive data in the format of object.
	When we create an object to a wrapper class, it contains a field/area and in this filed, we can store a primitive data type.

Whenever we send the data throughout the networks we should always prefer to send the data in the form of object.
If we want use any predefine logic (method), we cannot call on top of primitive variable, but we can call on top of object.
From above two conditions we need Wrapper class.

Primitive			wrapper class
 byte			Byte
short			Short
int			Integer
long			Long
float			Float
double			Double
char 			Character
boolean			Boolean

We can convert primitive data into wrapper class object in two ways.
	1. By using constructors.
	2. By using Methods.

Constructors in Warappers class:

1)java.lang.Byte:
	This class contains two constructors.
		Byte(byte value)--10
		Byte(String value)”10”
2)java.lang.Short
	This class contains two constructors.
	Short(short value)
	Short(String value)
3)java.lang.Integer
	This class contains two constructors.
		Integer(int value)
		Integer(String value)
4)java.lang.Long
	This class contains two Constructors
		Long(long value)
		Long(String value)
5)java.lang.Float
	This class contains three constructors.
		Float(float value)
		Float(double value)
		Float(String value)
6)java.lang.Double
	This class contains two constructors.
		Double(double value)
		Double(String value)
7)java.lang.Character
             This class contains only one constructor
		Character(char value)
8)java.lang.Boolean
	This class contains 	 two constructors
		Boolean(Boolean value)
		Boolean(String  value)
Java.lang.Number:
It is an abstract class.
It is the super class for Byte,Short,Integer, Long,Float, Double.
This class contains 4 abstract methods and two 
Concrete methods.
The above 4 abstract methods are implemented in their subclasses(6)
It implements java.io.Serializable

Note: All wrapper class implements Serializable and Comparable interfaces.
All the wrapper classes are immutable objects.

Note: All the wrapper class override the hashCode(),  toString(), equals().

public class WrapperDemo {
	public static void main(String[] args) {
		byte b = 100;
		Byte a1 = new Byte(b);
		Byte a2 = new Byte("127");
		System.out.println(a1);
		System.out.println(a2);
		Short a3 = new Short((short)120);
		Integer a4 = new Integer(125);
		Long a5 = new Long(120);
		Float a6 = new Float("12.34f");
		System.out.println(a6);
		/*Long a7 = new Long("120l");
		System.out.println(a7);*/
		Double a8 = new Double(23.34d);
		System.out.println(a8);
		Double a9 = new Double("23.34d");
		System.out.println(a9);
		Character a10 = new Character('a');
		System.out.println(a10);
		Boolean a11 = new Boolean("false");
		System.out.println(a11);
		Boolean a12 = new Boolean("true1");
		System.out.println(a12);
	}
}

public class WrapperDemo {

	public static void main(String[] args) {
		//Primitive data type to Wrapperclass type
		Byte a1  = Byte.valueOf((byte)100);
		Short a2 = Short.valueOf((short)122);
		Integer a3 = Integer.valueOf(100);
		Long a4 = Long.valueOf(123l);
		Float a5 = Float.valueOf(12.34f);
		Double a6 = Double.valueOf(12.34);
		Character a7 = Character.valueOf('a');
		Boolean a8 = Boolean.valueOf(false);
		System.out.println(a1+"...."+a2+"...."+a3+
				"...."+a4+"...."+a5+"...."+a6+"...."+a7+"...."+a8);
			
//Wrapper class data to prmitive datatype
		byte b1 = a1.byteValue();
		short b2 = a2.shortValue();
		int b3 = a3.intValue();
		long b4 = a4.longValue();
		float b5 = a5.floatValue();
	double b6 = a6.doubleValue();
	char b7 = a7.charValue();
	boolean b8 = a8.booleanValue();
		System.out.println(b1+"...."+b2+"...."+b3+
				"...."+b4+"...."+b5+"...."+b6+"..."+a7+"...."+a8);
//String data type to Wrapperclass type
		Byte a1  = Byte.valueOf("100");
		Short a2 = Short.valueOf("122");
		Integer a3 = Integer.valueOf("100");
		Long a4 = Long.valueOf("123l");//here l is not deleted
		//Long a4 = Long.valueOf("123");
		Float a5 = Float.valueOf("12.34f");
		Double a6 = Double.valueOf("12.34d");
		//Character a7 = Character.valueOf("a");
		Boolean a8 = Boolean.valueOf("false");
		System.out.println(a1+"...."+a2+"...."+a3+
				"...."+a4+"...."+a5+"...."+a6+"...."+a8);
			
			
	}		
}

public class WrapperDemo {

	public static void main(String[] args) {
		//String data type to Wrapperclass type
				Byte a1  = Byte.valueOf("100");
				Short a2 = Short.valueOf("122");
				Integer a3 = Integer.valueOf("100");
				//Long a4 = Long.valueOf("123l");//here l is not deleted

				Long a4 = Long.valueOf("123");
				Float a5 = Float.valueOf("12.34f");
				Double a6 = Double.valueOf("12.34d");
				//Character a7 = Character.valueOf("a");
				Boolean a8 = Boolean.valueOf("false");
				System.out.println(a1+"...."+a2+"...."+a3+
					"...."+a4+"...."+a5+"...."+a6+"...."+a8);
			//wrapper class to string	
				String b1 = a1.toString();
				String b2 = a2.toString();
				String b3 = a3.toString();
				String b4 = a4.toString();
				String b5 = a5.toString();
				String b6 = a6.toString();
				Character c = 'a';
				String b7 = c.toString();
				String b8 = a8.toString();
				System.out.println(b1+"...."+b2+"...."+b3+
						"...."+b4+"...."+b5+"...."+b6+"...."+b7+"...."+b8);
				System.out.println(b1+b2);
				
				//string data to primitive datatype
				byte c1 = Byte.parseByte("100");
				short c2 = Short.parseShort("234");
				int c3 = Integer.parseInt("122");
				long c4 = Long.parseLong("222");
				float c5 = Float.parseFloat("6666.88f");
				double c6 = Double.parseDouble("23.34");
				//char c7 = Character.parseChar("a");
				boolean c8 = Boolean.parseBoolean("true");
				boolean c9 = Boolean.parseBoolean("true1");
				System.out.println(c1+"...."+c2+"...."+c3+
						"...."+c4+"...."+c5+"...."+c6+"...."+c8+"...."+c9);
				
				//pdt to string
				String d1 = String.valueOf(127);
				String d2 = String.valueOf(127);
				String d3 = String.valueOf(127);
				String d4 = String.valueOf(127l);
				String d5 = String.valueOf(127.89f);
				String d6 = String.valueOf(127.78d);
				String d7 = String.valueOf('a');
				String d8 = String.valueOf(false);
				System.out.println(d1+"...."+d2+"...."+d3+
						"...."+d4+"...."+d5+"...."+d6+"...."+d7+"...."+d8);
				System.out.println(d1+d8);
				//System.out.println(127+false);
				
				String e1 = Byte.toString((byte)100);
				String e2 = Short.toString((short)200);
				String e3 = Integer.toString(100);
				String e4 = Long.toString(100l);
				String e5 = Float.toString(223.34f);
				String e6 = Double.toString(34.45d);
				String e7 = Character.toString('a');
				String e8 = Boolean.toString(false);
				System.out.println(e1+"...."+e2+"...."+e3+
						"...."+e4+"...."+e5+"...."+e6+"...."+e7+"...."+e8);
				System.out.println(e5+e6);
		}
}

AutoBoxing: converting or representing primitive data to object data directly is called autoboxing.
	ex: Integer i= 10;
	      Boolean b = false; 


AutoUnboxing: converting or representing wrapper class to primitive datatype data directly is called auto unboxing.
	ex: 
		int i = new Integer(100);
	 	boolean b = new Boolean(100);

Above statements valid from java 1.5 version.

Packages:

Package is a collection/group of classes,
interfaces, enums, and sub-packages.
Some fo the packages are given by java software and some of the packages are given by compiler.
The packages which are given by java s/w are called predefine packages.
The packages which are given by compiler or created by the compiler are called userdefine packages.
Package is a special java folder.
By using “package” keyword we can develop 
our own packages.
Syntax:
	package packagename;
Example:
	package p1;
Package is a second section of our program, first section is comment section. 
package statement is always first statement in java program.
Package statement is an optional statement.
But in the real time every .java file having package keyword.
The compilation and execution of the package program is different from normal program.

Compilation phase:

If we want to compile the java package related program we must use below option.
Syntax:	javac  -d  .  FileName.java
•Here “-d” option will specify the folder creation. We are giving  information to compiler to create one folder with the package name called nit.
•Here dot (“.”) operation will specify, current directory that means in nit folder and place the “dot class” file in that nit package.

Execution:
We should use the package name before the class name.
Syntax: java packagename.classname
creating package in current working directory:

package nit;
class A{
     public static void main(String...args){
       System.out.println("this is package               program");
     }
}
Filename: A.java
compilation: javac -d . A.java
execution: java nit.A

creating  package in some other directory:
package google;
class B{
     public static void main(String...args){
       System.out.println("this is package program");
     }
}
FileName: B.java
compilation: 
javac  -d otherdirectorypath filename.java
ex: javac -d E:\cj B.java
execution: other directory packages can be execute in two ways
1) shift out from current working directoy to package existing directory.
C:\Users\lenovo\desktop\jse(7to9)> cd E:\cj(enter)
E:\cj> java nit.B
2) setting the classpath
C:\Users\lenovo\desktop\jse(7to9)>
set classpath=.;E:\cj;
java nit.B

creating sub pakcages:
package nit.cj.ram;
class C{
public static void main(String...args){
System.out.println("sub packages");
}
}
filename: C.java
compilation: javac -d . C.java
execution: java nit.cj.ram.C

Access Modifiers:
Accessibility modifiers will provide permission to developer to use the variable, methods, class, interface, enum,abstract  class.
In java, we have four types of accessibility modifiers, they are
•	private.
•	default.(package-private)
•	protected.
•	public
private: private data can be access only with in the class level. We cannot acces out side of the class with in the same .java file, with in the same package or with in the outside package.
default:
if we are not declared any access modifier infornt of the variable, that is comes under default data.
from java 1.8 onwards we can default keyword infront of the methods of inerface.

default data can be accesable with in the same class, with in the same .java file, with in the same package, but not accessable with in the outside package class.

protected: protected can be acces with in the same class, with in the same .java file, with inthe same package, but not accessable with in the outside package class.

protected data some time acting as default data and some times as an public.
if other package class subclass of this class and data is static type, then protected data can be access out side of the package also.

Note: packages provides security to both default and protected data. Packages provide 100% security to default data and protected data. But some time package not provide security to protected data.

public: public data can be access any where in the project.



package ram;

public class A {
	private int a = 111;
	int b = 222;
	protected int c = 333;
	protected static int d = 444;
	public int e = 555;
	public static void main(String[] args) {
		A obj = new A();
		System.out.println(obj.a);
		System.out.println(obj.b);
		System.out.println(obj.c);
		System.out.println(obj.e);
	}

}
/*filename: A.java
execution java ram.A
compilation: javac -d . A.java
*/

package ram;

public class B {

	public static void main(String[] args) {

		A obj = new A();
		//System.out.println(obj.a);
		System.out.println(obj.b);
		System.out.println(obj.c);
		System.out.println(obj.e);
	}

}
/*filename : B.java
compilation: javac -d . B.java
execution: java ram.B
*/

package sam;
import ram.A;
public class C extends A{

	public static void main(String[] args) {
		A obj = new A();
		//System.out.println(obj.a);
		//System.out.println(obj.b);
		//System.out.println(obj.c);
		System.out.println(obj.d);
		System.out.println(obj.e);

	}
}
/*filename: C.java
 * compilation: javac -d . C.java
 * execution java sam.C
 * 
 * */

import statements are two types.
	1. static import statements.
	2. non-static/General import statement

General import statement can loads only classes,interface,abstract class,annotations,enum but not its members.(fileds,methods).

Static import statements import the static fields, static methods. These variables and members must be public.
It is introduced in java 1.5 version.
Note: fullyqualifiedname= packagename+classname/interfacename/enumname/abstractclass/annotationname;

package sam;
/*import static java.lang.System.out;
import static java.lang.System.err;
import static java.lang.System.currentTimeMillis;
import static java.lang.System.identityHashCode;
import static java.lang.System.exit;*/
import static java.lang.System.*;
class B{
	
}
public class C{
public static void main(String[] args) {
	System.out.println("static out filed");
	out.println("with out system class");
	err.println("err field");
System.out.println(System.currentTimeMillis());
	out.println(currentTimeMillis());
		B obj = new B();
out.println(System.identityHashCode(obj));
	out.println(identityHashCode(obj));
		exit(0);
System.out.println("program terminated inthe 		previous statement");
	}
}

Difference between #include and import statement?
#include will copy the code from library to program. so internally the code size will be increased.
import statement will give only response to java program.

Difference between import java.util.ArrayList and java.util.*;
--->In the first import statement we can access only ArrayList and its super class and interface functionalities.
--->In the second import statement we can access all classes and interface and abstract class related to util package.















Java archieve:(jar)
It is one compressed file in java statndard edition.
It contains java standard edition classes.
It can reduce file size.
With the help jar we can execute the programs also.

Webarchieve: (war).
It is also one compressed file in advanced java.
it contains the following files.
.servlet related classes
.jsp file
.html files
.jpeg files
.xml files
.properties files

Enterprise archieve:(ear)
It is also one compressed file in enterprese edition.
This file contains the following files.
.servlet related classes
.jsp 
.html
.jpeg
.xml files
.properties files
and enterprise java beans classes.

creating .jar file and add .class file:
=====================

public class A{
public static void main(String... args){
	System.out.println("jar file");
}
}

javac A.java

we are getting A.class file

jar -cf one.jar A.class

Delete the A.class file

set the one.jar file in the class path
then execute the program
java A
output: jar file.
-------------------
public class B{
public static void main(String... args){
	System.out.println("updating jar file");
}
}
javac B.java
we are getting B.class file

add B.class file to one.jar

jar -uf one.jar B.class

jar -tf one.jar

META-INF/MANIFIEST.MF
A.class
B.class

java A
java B
--------------------------------
Executing the java program with help of  javaw command.

java.io.*;
class D{
public static void main(String...ram)throws IOException{
FileOutputStream fos = new FileOutputStream("ram1.text");
PrintStream ps = new PrintStream(fos);
ps.write('d');
ps.write('e');
}
}

javac D.java
javaw D

--------------------------------
creating executable jar.
1)write one package program.
package suji;
public class A{
public static void main(String...ram){
	System.out.println("executablejar");
}
}
filename A.java
2)compile our package program with below syntax.
	javac -d . filename.java
	javac -d . A.java
3)take one notepad write below code in that.
Main-Class: suji.A
4)save above notepad with MANIFEST.MF
5)Add MANIFEST.MF file with the help of bellow code.
	jar -cvfm ud.jar MANIFEST.MF suji
6)type bellow in the commandprompt
	java -jar ud.jar.


note: class(A) must be public
          In the MANIFEST.MF file M,C must be capital letter after ':' we need give one space and after packagename.classname we need to click on enter button.
ud.jar name is userdefine.

Executing the java program by using batch file.
===============================
1) write one program
package  rabi;
public class  A{
	public static void main(String...ram){
	System.out.println("batchfile");
	}
}
filename A.java
2) take one notepad
write bellow code in that.
javac -d . A.java
java rabi.A
pause
and save with filename.bat 
	ex: run.bat
3) double click on run.bat
automatically commandprompt will be open and compile the program and executing the program and display the output.
==========================
ExceptionHandling:
Exception: Exception is an event , which can be raised by the jvm at runtime due to problem of logic.
Some of logical problems are:
class MM{
	public static void main(String[] s){
			String s1 = s[0];
			String s2 = s[1];
		System.out.println(s1+s2);
	}
}
javac MM.java
valid execution statements:
	java MM 123 234
	java MM ram sam
	java MM "%^&*(" "@#$%^"

Exception raised execution statements:
	java MM (click on enter)
java.lang.ArrayIndexOutOfBoundsException--0
	java MM 123 (enter)
java.lang.ArrayIndexOutOfBoundsException--1	
class MM{
	public static void main(String[] s){
	String s1 = s[0];
	String s2 = s[1];				System.out.println(s1+s2);
	int i = Integer.parseInt(s1);
	int j = Integer.parseInt(s2);
	System.out.println(i+j);
	}
}
	javac MM.java
	java MM 123 234
	o/P: 123234
	         357
	java MM ram sam
	o/p: ramsan
java.lang.NumberFormatException

class MM{
	int a =111;
	void m1();
	public static void main(String... ram){
		System.out.println("Main Method");
		MM obj = new MM();
		obj = null;
		//System.out.println(obj.a);	
		obj.m1();
	}
}

Note: on tof of null reference,  we cannot call any variables, methods.
If we call then we will get NullPointerException.
class MM{

	public static void main(String... ram){
	System.out.println("Main Method");
	//Object o = new String();//upcasting
	Object o = new Object();
	String s1 = (String)o;//downcasting
	}
}
java MM ---> java.lang.ClassCastException
class MM{
	public static void main(String... ram){
	System.out.println("Main Method");
		int a [] = new int[-6];
	}
}

Array dimentions must be positive or zero not Negative.
If we mention size in negative mode then we will get
java.lang.NegativeArraySizeException.

Before doing the downcasting, first we should do upcasting other wise we will get java.lang.ClassCastException
class MM extends Thread{
	public void run(){
		System.out.println("this is run method");
	}
	public static void main(String[] s){
		MM obj = new MM();
		obj.start();
		obj.start();
						
	}
}

javac MM.java
java MM
this is run method
java.lang.IllegalThreadStateException
class MM {
	public static void main(String[] s){
		int a = 10/0;
	}
}
javac MM.java
java MM
java.lang.ArithmeticException

class MM {
	int a =111;
	public static void main(String[] s){
		MM obj = new MM();
		obj=null;
		System.out.println(obj.a);
	}
}
javac MM.java
java MM
java.lang.NullPointerException

class MM extends Thread{
	public void run(){
		System.out.println("this is run method");
	}
	public static void main(String[] s){
		MM obj = new MM();
		obj.setPriority(11);//legal priorities from 1 to 10
		obj.start();
						
	}
}
javac MM.java
java MM
java.lang.IllegalArgumentException
class MM {
	public static void main(String[] s1){
		Object o = new Object();
		String s = (String)o;
						
	}
}
javac MM.java
java MM

class MM{
	public static void main(String... ram){
		System.out.println("Main Method");
		String s = "internationalization";//i18n
		System.out.println(s.charAt(20));
	}
}
In above program, we dont have 20th index position in string s.
But we tried to print the values thatwhy we are getting
java.lang.StringIndexOutOfBoundsException
java.lang.ClassCastException
float a = 10/0.0f-->infinity
float b = -10/0.0f--> -infinity
float c  = 0/0.0f--->NaN
float d = 0./0; -->NaN

Error: Error is an event which can be raised by jvm at runtime due to problem of lackof system resource.

class MM {
		MM obj = new MM();
	public static void main(String[] s1){
		MM obj = new MM();
		
	}
}

javac MM.java
java MM
java.lang.StackOverflowError	
Note: JVM version always greater than or equal to compiler version, otherwise we will get one runtime error that is:
	UnsupportedClassVersionError


class MM {
		static int a = 10/0;
	public static void main(String[] s1){
		
		
	}
}
javac MM.java
java MM
java.lang.ExceptionInInitilizerError


Use of ExceptionHandling:

1)When ever exception is raised internally jvm provides some predefine exception message.
Those message are not understand by the end user.
If we want to provide user friendly message then we can go for exception handling.

2)When ever exception is raised automatically the emaining statements are not executed.
Program abnormally terminated(without giving information to programmer).

so some necessary executable statements are not executed.
if we want to executed all necessary statements then we can go for exception handling.

we can achieve exception handling mechanisam with the help of following keywords
	those are
	1.try
	2.catch
	3.finally
	4.throw
	5.throws

try :  In this block we should always write exception raised statements.
	if we dont know which statements is raises exception then write all the  statements in try block.

catch: In this block we should hold exception object which was raised in the try block.

	this block execution is dependupon the try block.
	if try block not raised exception then catch block will not be executed.
	if try block raised exception then catch block will be executed.

finally: this block is not dependupon try block result.
	If try block is raised the execption or not , the finally block always executed.
	This block is used write the statements which are necessary to execute.
	Like databse connection, file closing.....
	This block is always executed.

When the finally block not executed?
	if programmer write System.exit(0), that means if we are explicitly stop the program then finally block not executed.
	if jvm execution suddenlly stopped then finally block not executed.

valid combinations between try and catch and finally  blocks:
(1)	
try{
}

catch(-){
}
finally{
}
-----------------
(2)
try{
}
finally{
}
-------------
(3)
try{
}
catch(-){
}
--------------
(4)
try{
}
catch(){
}
catch(){
}
catch(){
}
finally{
}
--------------
(5)
try{
}
catch(){
}
catch(){
}
catch(){
}
--------------
(6)
try{
	try{
	}
	catch(-){
	}
	finally{
	}
}
catch(-){
	try{
	}
	catch(-){
	}
	finally{
	}
}
finally{
	try{
	}
	catch(-){
	}
	finally{
	}
}
*************************************
Invalid statements:

try{
}
finaly{
}
catch{
}
************
try{
}
**********
catch(){
}
**********
finally{
}
********

try{
}
finally{
}
finally{
}
***********
try{
}System.out.println("we cannot write");
catch(-){
}System.out.println("we cannot write");
finally{
}
***********
try{
}
System.out.println("we can not write");
finally{
}
-------------------------------
Internal flow of Exception:
-------------------------------
When ever exception is raised in the program jvm will do the following things.
	1. jvm will check behaviour/characterstic of an execption.
		int a  = 10/0;
	2. based on characterstic of an exception, jvm will select one appropriate exception class.
		java.lang.ArithmeticException
	3. After selecting the class, jvm will create an object for that selected class.
 	    ArithmeticException ae= new ArithmeticException();
	4. While creating an object for that jvm will add description of an exception.
	like "/ by zero".
	5. finally jvm will handover to catch block or print on the console.

Exception in thread "main" java.lang.ArithmeticException: / by zero
	at collection.MapDemo.main(MapDemo.java:8)

	
We  have three ways(Methods) to printexception messages.
	1. printStackTrace().
	2. toString() 
	3. getMessage().

1.printStackTrace():
=============
	it will print execption message in the following format
java.lang.ArithmeticException: / by zero
	at exception.ExceptionDemo.main(ExceptionDemo.java:8)
it will print predefine exception class fully qualified name, description of an exception fullyqualified userdefine class name, method name, .java file name, line number,package name.

2. toString();
	java.lang.ArithmeticException: / by zero
it will print predefine exception class fully qualified name, description of an exception

3.getMessage();

	/ by zero
it will print only description of exception	

	

public class ExceptionDemo {
	public static void main(String[] args) {
	
		//int a = 10/0;
		//System.out.println("these statements are not executed");
		
		try{
			int a = 10/0;
		}
		catch(Exception e){
			e.printStackTrace();
			System.out.println(e.toString());
			System.out.println(e.getMessage());
			
		}
		System.out.println("These statements are executed");
		
		
	}
}	

public class ExceptionDemo {
	public static void main(String[] args) {
		try{
			int a = 10/0;
		}
		catch(Exception e){
			System.out.println("DONT ENTER ZERO AS AN DENOMINATOR");
		}
	}
}

In the first program we are execute the all the statements
in this program we did give user understandable exception message.
(***********************8
public class ExceptionDemo {
	public static void main(String[] args) {
		try{
			int a = 10/0;
			System.out.println("not executed");
		}
		//System.oyut.println("we cannot write the statement
		//	b/w try and catch")
		catch(Exception e){
			System.out.println("DONT ENTER ZERO AS AN DENOMINATOR");
			//System.exit(0);
			//in the above line we did explacitly stop the program
		}
		//System.oyut.println("we cannot write the
		//statement b/w finally and catch")
		finally{
			System.out.println("this block is always executed");
		}
		System.out.println("we can write the statements " +
				"after the finally block");
	}
}



*************************
public class ExceptionDemo {
	public static void main(String[] args) {
		try{
			//int a = 10/0;
			//Object o = new Object();
			//String s = (String)o;
			//int a [] = {10,20,30};
			//System.out.println(a[3]);
			//int a[] = new int[-1];
	        Object[] s = new Integer[4];
	        s[0] = 4.4;

		}
		//catch(Exception e){}
		catch(ArithmeticException e){
			System.out.println("dont enter zero as an denominator");
		}
		catch(ClassCastException e){
			System.out.println("Super class memory we can not" +
					" place into subclass reference ");
		}
		catch(ArrayIndexOutOfBoundsException e){
			System.out.println("we dont have any element in 3rd " +
					"index position");
		}
		catch(NegativeArraySizeException ne){
			System.out.println("we can not create array" +
					" with negative values");
		}
		catch(Exception e){
			System.out.println("we can not place double value in " +
					"integer array");
		}
		
		finally{
			System.out.println("this block is always executed");
		}
		
	}
}
If we are writing more than one catch blocks, java.lang.Exception class type parameter must be placed in last catch block.

The reason is whatever the exception is raised in the catch block that is always matched with Exception class type.(upcasting).

So the remaing catch blocks will not be executed.
public class ExceptionDemo2 {
	
public static void main(String[] args) {
	try{
	System.out.println("outer try block");
	try{
	System.out.println("inner try block");
	int a= 10/0;
	}
	/*catch(Exception e){
	
System.out.println("inner catch block");
System.out.println("dont enter zero as deono");
	}*/
	finally{
System.out.println("inner finally block");
	}
	}
catch(Exception e){
System.out.println("outer catch block");
}
finally{
System.out.println("outer finally block");
}
}
}
Note: If any exception is available in inner try block first jvm check inner catch block. 
if availble then inner catch will be executed.If not available or not matched then jvm checks outer catch block.
If available then outer catch block will be executed, if not available or parameter type exception class is not supports raised exception class(not matched) then raised exception class object handover to jvm.
public class ExceptionDemo2 {
	
	public static void main(String[] args) {
		try{
			System.out.println("outer try block");
			try{
				System.out.println("inner try block");
				int a= 10/0;
			}
			/*catch(Exception e){
				System.out.println("inner catch block");
				System.out.println("dont enter zero as deono");
			}*/
			finally{
				System.out.println("inner finally block");
			}
		}catch(Exception e){
			System.out.println("outer catch block");
		}
		finally{
			System.out.println("outer finally block");
		}
	}

}
Note: finally block notonly override the return value but also override the exception.











package exception;

class Student{
int sid = 111;
String sname = "ram";
	void m1()throws Throwable{
		Student s1 = this;
 		System.out.println(s1.sid);
		System.out.println(s1.sname);
		s1 = null;
		try{
		System.out.println(s1.sid);//NullPointerException
		}catch(Exception e){
			//throw e;
			throw e.initCause
			(new ClassCastException("we are " +	"calling variable on null reference"));
		}
	}
}

public class ChinedException {

	public static void main(String[] args)  {
		Student s = new Student();
		try {
			s.m1();
		} catch (Throwable e) {
			System.out.println(e.getCause());
		}
		
	}

}
**************************
package exception;

class MyException extends Exception{
	MyException(String msg){
		super(msg);
	}
	MyException(){
		
	}
void getAge(int age)throws MyException{
try{
	if(age >= 18){
System.out.println("This person is elegible for voting");
		}
		else 
			throw new MyException("This person is not elegible for voting");
		}catch(Exception e){
			throw e;
		}
	}
}
public class UserDefineExceptionDemo {
	public static void main(String[] args)throws MyException {
		MyException me = new MyException();
		me.getAge(18);
		/*try{
			me.getAge(17);
		}catch(Exception e){
			
		}*/
		
	}

}

If we want to develop user define exceptions, programer should do the following things.
	1) programer should take one userdefine class.
	   ex: class MyException{
	         }

	2) creating an object for that class.

	new MyException("This person is not elegible for 		voting");

	3) If we want to add exception message to object we need some logic, that logic is available in java.lang.Exception . 
	4) If we want to forward our control and exception message from sub class to super class we need bellow s yntax.
	ex: MyException(String msg){
		super(msg);
	      }
	5) If exception is predefine, then jvm will handover that exception object from try block to catch block.
	Here exception is userdefine, so we should give the information to jvm about our exception object.
	If we want handover the object from try block to catch block we need "throw" keyword.
	with the help of throw keyword we can give information to jvm about our object. that is make our object as an exception object.
	and also with the help of throw keyword we can send exception object from called method to calling method.
	If any method having throw keyword in its catch block that method must be use throws keyword.
throw: "throw" keyword is used to forward the exception object from one method to another method with in the application explicitly.

throws: If any compile time exception raised in our program, then we need to handle those exceptions. If we are not interest to handle, then we need handover those exceptions to jvm."throws" is used to forward the exception object from java application to jvm application then we can go for "throws" keyword.
	With the help of throws developer provide some information to compiler that is there may be chance of raising exeception in our method.
	Again with the help of throws keyword compiler will give information to programmer as a compiler time exception.
	If are using any method, which is raised exception, in that time compiler will throw compile time/checked exception.
	We can handle checked exceptiond in the following two ways.
	1. try and catch block
	2. throws keyword.
	
*****************************

public class ExceptionDemo {
	static int m1(){
		try{
			System.out.println("try block");
			//int a = 10/0;
			return 111;
		}
		catch(Exception e){
			System.out.println("catch block");
			//return 222;
		}
		finally{
			System.out.println("finally block");
			//return 333;
		}
		System.out.println("unable to write");
		return 444;
	}
	public static void main(String[] args) {
		System.out.println(m1());
	}
}

Note: If try and catch and finally  blocks having return statement, we can not write any statements after the finally block.
	try and catch block return statement values always replaced with finally block return statement value.

	If try and catch block not having any return statement, after the finally block we can write some other statements(optional) and also we should write return statement(mandatory) also.
--
Exception Chaining:

public class ExceptionDemo {
	int a = 111;
	static void m1()throws Throwable{
		try{
			ExceptionDemo ed = new ExceptionDemo();
			System.out.println(ed.a);
			ed = null;
			System.out.println(ed.a);
		}
		catch(Exception e){
			throw e.initCause(new ArithmeticException("we are calling" +
					" variable a on top of null reference"));
		}	
	}
	pub
lic static void main(String[] args) {
		int a = 10/0;
		try {
			m1();
		} catch (Throwable e) {
			//e.printStackTrace();
			System.out.println(e.getCause());
		}
	}
}

One Exception class provide the information like cause of exception of another excption class is called exception chaining.
If we want to add exception message to existed object we have one method that is "initCause()".
If we want read the exception message, we have one more method that is "getCause()".
Exceptions can be classified as follows.







Fully checked exceptions: Compiler will check class, and all it subclasses is called FCE. All compile time exceptions are comes under fully checked exceptions only.

Partially checked exceptions: 
	compiler will check class and not check all its subclass is called PCE.  
ex: java.lang.Exception,
      java.lang.Throwable
if method having return type and having try and catch blocks,we need to write return statement with value in both blocks.

if method having return type and having try and catch and finally blocks we no need to write return statement with values in try and catch blocks. Directly we can write return statement with value in finally block.

if try and catch having return statements then finally block return statement always overrides the try and catch block return statement.

If finally block having return statement we can not write any other statement after the finally block.

we can write some statements after finally block in the following condtions.
only try block having return statement (or)
only catch block having return statement.
If no block having return statement.

java.lang.Object:
	It is the super class for  all predefine and user define classes in java either directly or indirectly.
	class A{

	}
	
If we write class in the above manner java inernally converts into as an sub class of java.lang.Object class.

javac A.java
javap A
	class A extends java.lang.Object{
		A(){
			super();
		}
	}
	
java.lang.Object class having bellow methods.

1) getClass()
2) toString()
3) equals()
4) hashCode()
5) clone()
6) notify()
7) notifyAll()
8) wait()
9) wait(-)
10) wait(-,-)
11) finalize()

Among the 11 methods, we can override 5 methods only.
Remaing methods are not partispated in the method override concept.

	Below methods are partispated in the method override concept.
	1) toString()
	2) eauals()
	3) hashCode()
	4) clone()
	5) finalize()

toString():
	public String toString(){

     return getClass().getName() 	                +"@"+Integer.toHexString(hashCode());
	}	


In the above syntax : getClass() method will create java.lang.Class reference with specific class bytecode.

	getName() is the non-static method in java.lang.Class, with help of this method we will get class name of an loaded class.

i.e:  System.out.println(new Student());
S.o.p method internally calls toString() method.

This method(getClass().getName()) will print the output like "Student".

	"@" --> what ever the code which is available in double quotes as it is printed on the console.
	
	hashCode() method always return one unique identification number of memory in integer(decimal number system) format.
	This integer number will converted into hexa decimal format with the help of toHexString() of java.lang.Integer class.

	ex: Assume if hashCode() return 159--> this 159 will converted into  hexadecimal format like "9f".

	finally we will get one output as
		
		"Student@9f"
Note: Java avoids pointers concept with the help of toString().


package object;

class Employee{
	int eid;
	String ename;
	double esal;
	byte eage;
	
	Employee(int eid, String ename, double esal, byte eage){
		this.eid = eid;
		this.ename = ename;
		this.esal = esal;
		this.eage = eage;
	}
	public String toString(){
            System.out.println("controle comes to toString()");
//return getClass().getName()+"@"+Integer.toHexString				                                          (hashCode());
	return eid+" "+ename+" "+esal+" "+eage;
	}
}
public class ToStringDemo {

	public static void main(String[] args) {
		
Employee e1 = new Employee(101,"ram",15000,(byte)28);
		System.out.println(e1);

	}

}



hashCode():   This method provides a unique identification number of memory.
	When ever we use new keyword, jvm blindly provides new memory, that means new hashcode.

	Jvm is not check content to produce the hashcode. 
	Jvm is always provides a new hashcode for different object.

	If we want to provide hashCode based on content then we should go for override hashCode().

	"==" and equals() of Object class always calls jvm provides hashCode(). So if want call the userdefine hashCode() definetly we should override equals() of Object class.
	
equals(): This method is always checks hashCode() of objects, if hashCodes of any two objects are different then equals() method returns false, otherwise returns true.


package object;

class Student{
	int sid;
	String sname;
	
	Student(int sid, String sname){
		this.sid = sid;
		this.sname = sname;
	}
	static int i=0;
	@Override
	public int hashCode(){
		i++;
		return sid+sname.hashCode();
	}
	public boolean equals(Object o){
		
		if(o instanceof Student){
			Student s = (Student)o;
			if(this.sid == s.sid && this.sname.equals(s.sname)){
				return true;
			}
			else return false;
		}
		
		else return false;
				
		/*if(this.hashCode() == s.hashCode()){
			return true;
		}
		return false;*/
	} 
	
	
}
public class HashCodeDemo {

	public static void main(String[] args) {
		Student s1 = new Student(101,"ram");
		Student s2 = new Student(102,"sam");
		System.out.println(s1==s2);
		Student s3 = new Student(101,"ram");
		System.out.println(s1==s3);
		
		System.out.println("s1: "+s1.hashCode());
		System.out.println("s2: "+s2.hashCode());
		System.out.println("s3: "+s3.hashCode());
		System.out.println(Student.i);
		System.out.println("********************");
		System.out.println("jvm s1: "+System.identityHashCode(s1));
		System.out.println("jvm s2: "+System.identityHashCode(s2));
		System.out.println("jvm s3: "+System.identityHashCode(s3));
		
		System.out.println("********************");
		System.out.println(s1.equals(s2));
		System.out.println(s1.equals(s3));
	}

}

cloning:
	Creating new object with updated data is called cloning.
	In the clonning, we will get new object with new memory.
	
	For doing cloning java provides one predefine method called clone(), this is protected method in java.lang.Object class.

	clone() will throws one checked/compile time exception i.e "java.lang.CloneNotSupportedException"

	If any class data is partispated in the cloning that class must be implements java.lang.Cloneable interface.
java.lang.Cloneable is an marker interface.
(An interface which doesnot contains any methods)

	When ever we doing the cloning nonstatic data is not going to be loaded.
(creating new object with new memory with updated data without duplicate code is called cloning).
************************
package object;

class Address implements Cloneable{
	String cityName = "hyderabad";
	String stateName = "telangana"; 
			
}
public class Student implements Cloneable{
	int sid = 111;
	String sname = "ram";
	Address addr = new Address();
	
	public static void main(String[] args) throws
	CloneNotSupportedException{
		Student s1 = new Student();
		Student s2 = (Student)s1.clone();
		
		System.out.println(s1.sid);
		System.out.println(s1.sname);
		System.out.println(s1.addr.cityName);
		System.out.println(s1.addr.stateName);
		System.out.println("************");
	
		System.out.println(s2.sid);
		System.out.println(s2.sname);
		System.out.println(s2.addr.cityName);
		System.out.println(s2.addr.stateName);
		System.out.println("************");
		
		s1.sid = 222;
		s1.sname = "sam";
		s1.addr.cityName = "vizag";
		s1.addr.stateName = "AndharaPradesh";
		
		
		System.out.println(s1.sid);
		System.out.println(s1.sname);
		System.out.println(s1.addr.cityName);
		System.out.println(s1.addr.stateName);
		System.out.println("************");
	
		System.out.println(s2.sid);
		System.out.println(s2.sname);
		System.out.println(s2.addr.cityName);
		System.out.println(s2.addr.stateName);
		System.out.println("************");
		
		s2.sid = 333;
		s2.sname = "suji";
		s2.addr.cityName = "sklm";
		s2.addr.stateName = "AP";
		
		
		System.out.println(s1.sid);
		System.out.println(s1.sname);
		System.out.println(s1.addr.cityName);
		System.out.println(s1.addr.stateName);
		System.out.println("************");
	
		System.out.println(s2.sid);
		System.out.println(s2.sname);
		System.out.println(s2.addr.cityName);
		System.out.println(s2.addr.stateName);
		System.out.println("************");
	}

}
***********************
Cloning is two types 
	1. Shallow cloning
	2. Deep cloning.

Shallow cloning:
	if we are doing updation on cloned object or existed object those updations will be effected to other objects is called shallow cloning.
	ex: Bellow program

Deep cloning:
	if we are doing updation on cloned object those updations will not be effected to existed object is called deep cloning.
	ex: Bellow program.


JAVA I/O (Input/Output) Streams
Using Java application, we can store the data permanently in a specific place either in file or in database. If java application wants to communicate with file and database we need some low level predefine logic, that given by java software in two packages.                                                                                                             java.io ,	java.sql                                                                                                                                                         java. io package facilitates communication between java  and files only. java.sql package facilitates communication between java and different databases(oracle, my-sql, tera-data etc) .The logic used to store data permanently in one place is called PersistentLogic and the location is called Persistent Store. or database.                                                                                                                                                                       Stream: The two-way data flow between java application and files is called stream.                                     In java, there are two types of streams.                                                                                                                              1) Byte stream.                                                                                                                                	                                      2) Character stream.										        Data flow between java and files in form of byte by byte constitutes the Byte stream. Data flow between java and files in form of character by character constitutes the Character stream.            java.io.OutputStream:: java.io.OutputStream is the super class for all output stream classes under the byte stream for writing the data into files.                                                                                                                 It is an abstract class. This abstract class implements two interface those are:                                                     1) java.io.Closeable.  2)java.io.Flushable.								In this class we have one abstract method that is write(int).                                                                       The various subclasses of this class they are:                                                                             ByteArrayOutputStream,FileOutputStream,FilterOutputStream,	ObjectOutputStream,  PipedOutputStream.                                                                                                                                                              With the help of FileOutputStream, we can write data in byte format only. The data is stored in the file in the form character. FileOutputStream uses either existing file or new file. If file is not exists FOS created a new file with help given file name. If file is existed FOS uses existed file name.                                   write() method and read() method always throws IOException. All io package classes throwing one more compile time exception that is  java.io.FileNotFoundException.
FileInputStream is the basic class for reading the data from file. This class always needs existed file name. F IS class read the data from the file in the form of byte by byte.The data is reading in the form int format.
import java.io.*;
public class FOSFISDemo{
	public static void main(String[] args) throws FileNotFoundException,IOException{
		FileOutputStream fos = new FileOutputStream("vaibhav.text"); 
		fos.write('v');	fos.write(65);	fos.write('Z');
		System.out.println("data was entered in the form of character");
		FileInputStream fis = new FileInputStream("vaibhav.text");
		int i= 0;
		while((i=fis.read())!=-1){
			System.out.println(i+"..."+(char)i);
		}System.out.println("data was sucessfully read");
}}
Note:	FileOutputStream fos = new FileOutputStream(“vaibhav.text”, true);
The above syntax allows new data to be appended to existing data, while keeping the old data intact.
java.io. InputStream:: java.io.InputStream is the super class for all the input stream classes under byte stream for reading data from file. The various subclasses of this class are:  AudioInputStream, ByteArrayInputStream,	FileInputStream, ObjectInputStream, PipedInputStream,  SequenceInputStrea StringBufferInputStream.                                                      					FileOutputStream and FileInputStream having the drawback like storing the data in the form of character and reading the data in the form of integer. We cannot read the data in the different data type format. To resolve this problem we can go for DataInputStream and DataOutputStream.                  FOS,FIS are basic classes for writing and reading the data to and from the files.                                                          All classes are using these two basic classes for communicating with the files.
import java.io.*;
public class DOSDISDemo {
public static void main(String[] args)        throws FileNotFoundException,IOException{
FileOutputStream fos = new FileOutputStream("Vaibhav1.text");	                               DataOutputStream dos = new 	DataOutputStream(fos); dos.writeByte(100);dos.writeChar('a');	dos.writeInt(120);		    dos.writeBoolean(false);FileInputStream fis = new FileInputStream("Vaibhav1.text"); DataInputStream dis = new DataInputStream(fis); System.out.println(dis.readByte());System.out.println(dis.readChar()); System.out.println(dis.readInt());System.out.println(dis.readBoolean());                                             }                                                                                                                                                                    }
Note: DataOutputStream  and DataInputStream classes are not directly communicate with files, first these two classes are communicate with FileOutputStream and FileInputStream respectively, by using FOS and FIS functionalities DOS and DIS are communicating with files for writing and reading the data in the form of different datatypes.
ByteArrayOutputStream :-
import java.io.*;                                                                                                                                                         public class ByteArrayDemo{                		                                                                                                           public static void main(String []args) throws FileNotFound Exception {
			FileOutputStream fos1 = new FileOutputStream(“siddharth1.text”);
			FileOutputStream fos2 = new FileOutputStream(“siddharth2.text”);
			ByteArrayOutputStream bos = new ByteArrayOutputStream();
			bos.write(100);	bos.writeto(fos1);bos.writeto(fos2);
			System.out.println(“Success”);
			FileInputStream fis1 = new FileInputStream(“Siddharth1.text”);
			FileInputStream fis2 = new FileInputStream(“Siddharth2.text”);
			int i = 0;
			while((i=sis.read()) != -1) {
				System.out.println(i+”.....”+(char)i);
			}
		}
}
Serialization:- Converting/ translating data in the form of object from java supported architecture to file support architecture is called serialization.In the process of serialization, the data is encrypted according to java internal algorithms.To support serialization, java provides pre-defined class - java.io.ObjectOutputStream(writeObject(obj)).It is mandatory that the object that is being serialized implements java.io.Serializable interface (if not - NotSerializableException).
De-Serialization:-To translate the data from file support format to java support format is called de-serialization.De-serialization is supported by pre-defined class java.io.ObjectInputStream(readObject(obj)).readObject() method  will throws one compile time exception that is ClassNotFoundException.In the deserialization jvm will create one new object, without executing the constructor.
java.io.serializable:- It is a marker interface i.e it does not contain any methods.Any class implementing Serializable, JVM will treat that class as special object and thereby participates in serialization.
import.java.io*;
class Student implements serializable{
	int sid = 111;	String sname = “siddharth”;	int fee = 1000;	String password = “kick”;
}
public class SerializationDemo {
	public static void main(String []args) throws IO Exception, ClassNotFoundException
	FileOutputStream fos = new FileOutputStream(“suresh.ser”);
	ObjectOutputStream oos = new ObjectOutputStream(fos);
	Student s = new Student();oos.writeObject(s);	System.out.println(“serialization success”);
	FileInputStream fis = new FileInputStream(“suresh.ser”);
	ObjectInputStream ois = new ObjectInputStream(fis);
	object obj = ois.readObject();Student s1 = (Student)obj;	System.out.println(s1.sid);
	System.out.println(s1.sname);	System.out.println(s1.fee);	System.out.println(s1.password);
}}}
Note: To stop an object from participating in serialization, we should mention data as ‘transient’ with the keyword transient String password = “kick”;	output -> NULL Static data is also does not participate in serialization.
	static int sid = 111;
	output -> 0
During Execution and in the process of deserialization, password is returned as NULL, but static value which is initially ) is replaced by original value - 111.
Customized Serialization & De-serialization:-
import java.io.*;
class Student implements Serializable {
	int sid = 111;	String sname = “siddharth”;	int fee = 1000;
	transient String password = “ramchandra”;
private void writeObject(Object output stream oos) throws Exception {
	oos.default.writeObject();password = “123ramchandrahellohowru”;
	oos.writeObject(password);
}
private void readObject(Object Input Stream ois) throws Exception {
	ois.default readObject();	String password1 = (String)ois.readObject();
	password = password1.substring(3,13);
}
public class SerializationDemo {
	public static void main(String []args) throws IO Exception, ClassNotFoundException
	FileOutputStream fos = new FileOutputStream(“suresh.ser”);
	ObjectOutputStream oos = new ObjectOutputStream(fos);
	Student s = new Student(); oos.writeObject(s); System.out.println(“serialization success”);
	FileInputStream fis = new FileInputStream(“suresh.ser”);
	ObjectInputStream ois = new ObjectInputStream(fis);
	object obj = ois.readObject();Student s1 = (Student)obj;	System.out.println(s1.sid);
	System.out.println(s1.sname);	System.out.println(s1.fee);
	System.out.println(s1.password);
}}}
Object Graph Serialization:-
class Dog implements Serializable {
	Dog(){		System.out.println(“zero argument constructor”);	}
Cat c = new Cat();											}
Class Cat implements Serializable {
Rat r = new Rat ();
}
Class Rat implements Serializable {
int i = 111;
}
public class SerializationDemo {
public static void main(String []args) throws IO Exception, FilenotFound Exception {
/* instead of student object creation in the above main method, we create dog object and pass it to write object */
Dog d = new Dog ();
oos.writeObject(d);
/*instead of casting to Student, we should cast into Dog*/	
		Dog d1 = (Dog)obj;
		System.out.println(d1.c.r.i);
}}}
Note: in the above program, if any class (Dog/Cat/Rat) does not implement serializable interface, then we get a java.io.NotSerializable Exception.
Importance of order:-
class Dog1 implements Serializable {
	int i = 111;
}
Class Cat1 implements Serializable {
int j = 222;
}
Class Rat1 implements Serializable {
int k = 333;
}
public class SerializationDemo {
public static void main(String []args) throws IO Exception, FilenotFound Exception {
FileOutputStream fos = new FileOutputStream(“balaji.text”);
		ObjectOutputStream oos = new ObjectOutputStream(fos);
		Dog1 d = new Dog1();Cat1 c = new Cat1();Rat1 r = new Rat1();
		oos.writeObject(d);oos.writeObject(c);	oos.writeObject(r);
		System.out.println(“Success”);
		FileInputStream fis = new FileInputStream(“balaji.text”);
		ObjectInputStream ois = new ObjectInputStream(fis);
		Rat1 r1 = (Rat1)ois.readObject();Dog1 d1 = (Dog1)ois.readObject();                                                           
Cat1 c1 = (Cat1)ois.readObject();
/* the above order generates an error. Order is very important and order given in serialization should be maintained for deserialzation also. */ 
Serialization with Inheritance:
•	If any sub-class undergoes serialization, then parent class is serialized automatically.
	class Animal implements Serializable{
		int i = 111;
	}
	class Cow extends Animal implements Serializable {
		int j = 222;
	}	
			(program as above)
		Cow c = new Cow();
		oos.writeObject(c);
			(program as above)
		Cow c1 = (cow)ois.readObject();
		System.out.println(c1.i);
		System.out.println(c1.j);
Note:
•	If parent class implements Serializable then the sub class need not always implement Serializable.
class Animal implements Serializable{
	int i = 111;
} 
class Cow extends Animal {
		int j = 222;
}
•	If sub-class implements Serializable and the parent class does not implement Serializable, then the super class data does not participate in serialization.
	class Animal {
	int i = 111;
} 
class Cow extends Animal implements Serializable {
		int j = 222;
}
		Cow c = new Cow();
		c.j = 333;
		c.i = 444
output -> j = 333
	   i = 111 (not 444 because it did not participate in serialization) 	
Externalization:
class Student implements Externalizable {
	int sid;	String sname;	int sage;
public Student (){
	System.out.println(“student constructor”);
}
public Student (int sid, String sname, int sage){
	super();	this.sid = sid;this.sname = sname;this.sage = sage;
}
public void readExternal(Object input ois) throws IO Exception, ClassNotFoundException{
	String sname1 = (String)ois.readObject();sname = sname1;
public void writeExternal(object output oos) throws IO Exception, ClassNotFoundException{
	sname = “krishna”;	oos.writeObject(sname);
	}
}
public class Serialization Demo {
public static void main(String [] args) throws FileNotFoundException{
	Student s = new Student(101, “peri”, 24);
	oos.writeObject(s);
	object obj = ois.readObject();	Student s1 = (Student)obj;System.out.println(s1);
}
}
•When reading data from file in the process of de-externalization, public zero argument constructor is mandatory. If not available - invalid class Exception.
Difference betweenSerialization&Externalization:
In Serialization, everything is taken care of by JVM (no user input) whereas in Externalization, everything is taken care of by programmer only. Performance of serialization is low as compared to Externalization. Serialization needs Serializable interface (marker interface - no method).Externalization needs Externalizable interface.Externalizable interface - needs two methods writeExternal() & readExternal(). Serialization does not require any default constructors whereas Externalization needs public zero arguemnt constructor. In Serialization there is a use of transient keyword but in externalization no use.	
import java.io.*;
public class FWAFRDemo {
	public static void main(String[] args)throws FileNotFoundException,IOException {
		FileWriter fw = new FileWriter("sony.text");
		fw.write(100);	fw.write('a');	fw.write('z');	fw.flush();	fw.close();
		FileReader fr = new FileReader("sony.text"); int i=0;
		while((i=fr.read())!=-1){
			System.out.println(i+"...."+(char)i);
}}}
BufferedReader:
It is having two methods.
1. readLine(): will read the data in the form of String.2. read(): will read only one single character ascii value. With the help of BufferedReader we can read the data from keyboard and also from files.
import java.io.*;
import java.util.StringTokenizer;
public class FWAFRDemo {
	public static void main(String[] args)throws FileNotFoundException,IOException {
		InputStreamReader isr = new InputStreamReader(System.in);
		BufferedReader br = new BufferedReader(isr);
		System.out.println("enter some data");	String s = br.readLine();	System.out.println(s);
		System.out.println("enter some data");	int i = br.read();	System.out.println(i);
		FileReader fr = new FileReader("sony.text");
		BufferedReader br1 = new BufferedReader(fr);
		String s1 = br1.readLine();System.out.println(s1); int total = 0;
		StringTokenizer st = new StringTokenizer(s1," ");
		while(st.hasMoreTokens()){
			total = total+Integer.parseInt(st.nextToken());
		}
		System.out.println(total);
}}
java.io.Console:
import java.io.*;
class ConsoleDemo {
public static void main(String[] args)
throws FileNotFoundException,IOException {
	Console con = System.console();	System.out.println("enter some data");
	String s = con.readLine();System.out.println(s);	System.out.println("enter some data");
	char c[] = con.readPassword();	System.out.println(c);	String s1 = new String(c);
	System.out.println(s1);
}}
System.out.println():
	out is a static field in System class. So we are called out filed by using class name(System).
	But println() is not available in System class, this println() available in java.io.PrintStream. It is a non-static method. If we want call println() we need PrintStream class reference.  If we are creating reference PrintStream and calling println() the data is not print on the console, the data will be print on the file. If we print the data on the console, we System.out.  This System.out will represents output device like console. If we are using System.out.println() then only the data will print on the console.
import java.io.FileNotFoundException;
import java.io.FileOutputStream;
import java.io.IOException;
import java.io.PrintStream;
public class FWAFRDemo {
	public static void main(String[] args)throws FileNotFoundException,IOException {
FileOutputStream fos = new FileOutputStream("mona.text");
PrintStream ps = new PrintStream(fos);ps.println("data is not print on console");
System.out.println("data is print on console");
System.err.println("this is also represents console");
System.setOut(ps);System.setErr(ps);System.out.println("data is print on console");
System.err.println("this is also represents console");
}}
MULTI –THREADING
MultiTasking: 
	Processing/Executing more than one task /several tasks simultaneously is called MultiTasking.
There two types of multitasking. They are:
 	Process based multitasking. 
 	Thread based multitasking.
Processed Based Multitasking:
Processing multiple tasks simultaneously based on address/process is called process Based Multitasking.
Here each job can be done by separate process.
Example: 
The best example of Process Based Multitasking is when we reading a book first we see the word after we are reading/speaking the word. Here seeing the word is one task and reading word is another task. These two tasks can be done by simultaneously.
In the Process Based Multitasking switching one context /area to another context/ area is take more time.
Each and every process having its own address/context, so switching from one context to another context takes more time. It is heavy weight process.
Resources consuming is more.
 
Thread Based Multitasking:
Processing multiple jobs/tasks simultaneously based on Thread is call Thread Based Multitasking.
Here each task is separately individual part. This is best suitable for programming. Thread uses less resources when compare Process. We simply say this; collection of threads is called process. Here all threads are placed in a one context/ area, so switching the control from one context to context is not take that much of time when compare to Process switching. That why comparing process based multitasking, thread based multitasking best suitable for application performance. 
We can also say thread based multitasking as Multithreading.
 
In the both cases of multitasking we should get performance, the reason is reducing the time that means complete the task quickly. This is light weight process. Resource consuming is less. Java provides huge libraries to work with multi threading in the form of API like Runnable, Thread, ThreadGroup.
Thread:
A thread represents a separate path of execution of a group of statements.
In java program, we have group of statements, these are executed one by one statements by JVM. We can also specify Thread is a stack which is created in Java Stacks Area. In our program the default thread is main, which is executed by JVM.
(Q) Why should we go for Multithreading?
? Threads are mainly used in server-side programming.
?Threads can give the response to all the clients with in the same time.
? Threads can also used at developing games, animation.
? In java simply we can say JVM is a process, which is by default having two Threads for each and every program. They are:
•	main:  Used to execute the methods.
•	garbage collector: Deleting the objects, which are not used by using mechanism called Mark and Sweep.
When we working with threads we can see two types of execution, they are:
Sequential execution: A single thread can executes each and every method one by one. In sequential execution the time for the completion of work is more.
Concurrent execution: Methods are executed simultaneously. The completion of the work is very fast when compare to sequential execution.                            Note: At a time a thread can execute only one time.
In concurrent execution the tasks will be processed in the bellow manner.
Start? suspend?resume?end.
In this process user should create multiple threads to work with multiple tasks.
Creation of UserDefine Thread:
If  we want to create user define thread in java we
 have two ways.
a.	By extends java.lang.Thread class
b.	By implements java.lang.Runnable interface.
By extends java.lang.Thread: 
package thread;
public class MyThread extends java.lang.Thread{
	public void run(){
		System.out.println("varun/userdefine thered" +
				" priority: "+Thread.currentThread().getPriority());
		for(int i =0; i< 10; i++){
			System.out.println(Thread.currentThread().getName()+
				".."+i);
		}
	}
	public static void main(String[] args) {
		MyThread mt = new MyThread();
		//mt.run();
		mt.setName("varun");
		//mt.setPriority(10);
		//mt.setPriority(-11);
		mt.start();
		//mt.start();
		//mt.stop();
		System.out.println("main thered priority: "+
		Thread.currentThread().getPriority());
		for(int i =0; i< 10; i++){
			System.out.println(Thread.currentThread().getName()+
					".."+i);
			//Thread.currentThread().stop();
		}
		System.out.println(Thread.MIN_PRIORITY);
		System.out.println(Thread.NORM_PRIORITY);
		System.out.println(Thread.MAX_PRIORITY);
	}
}
First we should take one class, that class must be extends
java.lang.Thread class. The reason if we want develop any
User define thread class, that class must be need 
java.jang.Thread class functionalaties.
	class MyThread extends java.lang.Thread{
}
If we want execute user define logic with the help of user
define thread, that code must be write within the run().
All the main method statements execute by the main thread.
If we are calling any method from main(), that called 
Method statements also execute by the main thread only.

So if we are calling run () directly, then main thread will
be execute that method but not user define thread.
If we want execute run () by the user define thread then we
should we start().

start () of Thread class automatically calls user define
override run(). That means that run () internally execute
by user define thread only.


If we want start the thread we need start().
If we want stop the thread we have stop().
If we want to know the thread name
	Then we should bellow syntax.
	Thread.currentThread().getName().
If we want to give name to thread, we have method like
setName(String name).
Thread priorities are start from 1 to 10.
Main thread priority is 5. Whatever the threads which are
created by the main thread those thread priority is also
5.

Java provides three constants to know the priority of
an threads those are
	MIN_PRIORITY
	NORM_PRIORITY
	MAX_PRIORITY
Thread minimum priority is 1.
Normal priority is 5
Maximum priority is 10.
If we want setting priority and getting priorities of 
a thread we have two predefine methods.
	1.setPriority()
	2.getPrioity()
If we are setting thread priorities more than 10 and 
Less than 1 then we will get runtime exception this is
Java.lang.IllegalArgumentException.
We cannot call start () more than one time on one single
Thread object.
If we are calling start () more than one time, then we
will get one runtime exception java.lang.IllegalThreadStateException.

Thread execution is not reliable, thread execution
entirely depend upon JVM.

Q) Can we override start () in our class?
A) Yes. We can.
If we calling start () on user define thread object, then
control not goes to start () of Thread class. User define
Start () will be execute. In this time run () not executed.
If we are overriding the start () method, that method will
be treated as a normal method by the JVM.

Note: If we want to call the run () by the user define
thread, then we should forward our control to 
java.lang.Thread class start ().

Creating user define thread by implementing 
java.lang.Runnable interface

Q)Difference between extends Thread implements Runnable?
A)If we extends Thread, we are unable to extends some other class functionalities, the reason java does not support multiple inheritance through classes.

But if we go for Runnable interface we can access Runnable functionalaties and some other class funcationalities.

If we extends Thread class, we are unable use same object more than one time. If we call start() on same object more than one time we will one exception that is java.lang.IllegalThreadStateException.
But if we implements Runnable, we can same object more than one with the help  of Thread class reference.

If we extends Thread class we will get all functionalites, but  if we go for Runnable we will get required functionalty.










Controlling the threads:
	1. yield ():
	If we want forwarding the control from one thread to 
another thread based on priority then we can go for yield().
Before giving the control to waiting thread, currently
executing thread checks priority of waiting thread.
If waiting thread priority is greater than or equal to
current thread then automatically control goes to 
waiting thread.


2. join() : if we want push the waiting thread into exec-
ution state then we can use join(). Java provide three
types of join methods.
	join()
	join(-)
	join(-,-)

Q) What is difference between join() and join(-)?
A) If we are using join(), then joined thread will
execute entire work. Whereas join(-) will gives
chance to thread only some period of time.
within the period of time if work is complete
then control goes to waiting thread, otherwise
In the middle of the work only control goes to 
waiting thread.

3.sleep():
This method is use to placing the current 
execution thread in sleep mode for particular time.
We have two different sleep methods.
	sleep(-)  and sleep(-,-)
Note: Both join() and sleep(-) are throwing compile time 
Exception. That is java.lang.InterruptedException

Differences between join and sleep and yield methods.
			Yield		join		sleep
Number of method	1 		3		  2
Static 		yes		no		yes
Native			yes		no		yes
Final			no		yes		no
Interrupted		no		yes 		yes
Exception
Synchronized		no		2—syn(join(-)  no
					Join(-,-)
					Join()(not synt)



Synchronization:
It is a mechanism, which is used to allow only one thread to execute the entire resource.
If more than one thread is executing the only one common resource, then we should allow only one thread at a time. After complete the work by the allowed thread,
then remaining threads will get chance to execute.

If we want to get these type of functionalities, we should go for synchronization.
If we want to achieve synchronization in java, we have one keyword that is “synchronized”. 

“synchronized” keyword we can be applied on top of methods and blocks.

Ex: synchronized void m1 () {
//synchronized method
     }
	Void m2 () {
		synchronized (MyThread.class){
			//synchronized block
}
}

class Display{
 synchronized void wish(String msg){
		for(int i=0;i<10;i++){
		System.out.println("good morning  "	+msg);
		}
		try{
			Thread.sleep(5000);
		}catch(Exception e){}
	}
}

class MyThread1 extends Thread{
	Display d1;
	String msg;
	MyThread1(Display d1, String msg){
		this.d1 = d1;
		this.msg=msg;
	}
	public void run(){
		d1.wish(msg);
	}
}
public class SynchronizedDemo {

	public static void main(String[] args) {
		Display d = new Display();
		MyThread1 m1 = new MyThread1(d,"ram");  
		MyThread1 m2 = new MyThread1(d,"sam");
		m1.start();
		m2.start();
	}
}

In the following scenario we have two threads on
two different resources, that means every thread
has it own resource, in that time if we are applying
synchronization there is no usage.

class Display{
 synchronized void wish(String msg){
		for(int i=0;i<10;i++){
		System.out.println("good morning  "	+msg);
		}
		try{
			Thread.sleep(5000);
		}catch(Exception e){}
	}
}

class MyThread1 extends Thread{
	Display d1;
	String msg;
	MyThread1(Display d1, String msg){
		this.d1 = d1;
		this.msg=msg;
	}
	public void run(){
		d1.wish(msg);
	}
}
public class SynchronizedDemo {

	public static void main(String[] args) {
		Display d = new Display();
		Display d1 = new Display();
		MyThread1 m1 = new MyThread1(d,"ram");  
		MyThread1 m2 = new MyThread1(d1,"sam");
		m1.start();
		m2.start();
	}
}
In this particular time we should go for locking 
mechanism.
	We have two types locking.
1.	Class level locking.
2.	Object level locking.

class DemoClass{
	public void demoMethod(String str){
		
		//synchronized(this){  //object level locking  
		synchronized(DemoClass.class){  //class level locking
			for(int i=0;i<10;i++){
				System.out.println("good morning"+"..."+str);
			}
			try{Thread.sleep(2000);
			}catch(Exception e){
				e.printStackTrace();
			}
		}
}
}
class Supported extends Thread{
	DemoClass d;
	String str;
	Supported(DemoClass d,String str){
		this.d =d;
		this.str = str;
	}
	public void run(){
		d.demoMethod(str);
	}
	
}
public class SynchronizedDemo1 {

	public static void main(String[] args) {
		DemoClass dc = new DemoClass();
		DemoClass dc1 = new DemoClass();
		Supported s =  new Supported(dc,"ram");
		Supported s1 =  new Supported(dc1,"sam");
		s.start();
		s1.start();
		
	}

}

Drawbacks: Performance will be decreases.

The reason is multiple threads are in the waiting mode,
program execution will take more time, if execution 
time is increases automatically performance will be 
decreases.

But synchronization is very good at result. Provides 
accurate/reliable results.

resume() and suspend():
	With the help of suspend() we can stop the particular
Thread. 
	With the help of resume() we can start the particular 
thread.
Thread Life cycle:
 



Inter Thread communication:
class Customer{  
	int amount=10000;  
  
	synchronized void withdraw(int amount){  
			System.out.println("going to withdraw...");  
			if(this.amount<amount){  
					System.out.println("Less balance; waiting " +
							"for deposit...");  
					try{
						//wait(5000);
						wait();
					}catch(Exception e){
					}  
			}
			this.amount=this.amount-amount;  
			System.out.println("After withdrawl: "+this.amount);
			System.out.println("withdraw completed...");  
	}  
	synchronized void deposit(int amount){  
			System.out.println("going to deposit...");
			System.out.println("before deposit: "+this.amount);
			this.amount =  this.amount+ amount;  
			System.out.println ("depositcompleted... ");
			System.out.println("After Deposit: "+this.amount);
			notifyAll();
			//notify();
	}
}
  
public class WaitTest{  
	public static void main(String args[]) throws InterruptedException{
		int a = 10/0;
	final Customer c=new Customer();  
		new Thread()
		{
			public void run(){	
				c.withdraw(15000);
			}  
		}.start();  
		new Thread(){  
			public void run(){
				c.deposit(10000);
				}  
			}.start();  
			
		}
	}  

COLLECTION FRAME WORK
Drawbacks of Arrays:
 	Arrays are fixed in size.
o	int a [] = new a [10]
o	Here “10” is size of an array.
 	Once we creating an array there is no chance of increasing/decreasing its size based on our requirement.
 	Array can hold only homogeneous data elements.
o	Teacher t[]=new Teacher[10];
 	Here we can add only teacher object, but it cannot hold student, employee objects data.
 	If we want overcome this problem we should go for Object array.
o	Object o[] =new Object[10];
o	o[1]=”rams”
o	Here “rams” is an string object
o	o[2]=new Teacher();
o	Here we did place the Teacher object.
 	Arrays can allow the duplication code/data.
o	int a[]={10,20,6,34,10}
 	Arrays don’t provide any low level services.
 	Arrays don’t have any searching, sorting logic by default; we have to write the entire low level code/functionalities.
 	To resolve these above problems we should go for collections framework.
Collection framework:
?	Collection framework is a class library to handle group of objects.
?	It is implemented in java.util package. It has been including in java 2.0.
?	It is collection of classes and interface.
?	Each and every class and interface having its own priority and advantages.
Advantages of Collection:
 	The size must be increase dynamically, based on our application requirement.
o	We can overcome the problem of memory wastage.
o	We will get the application efficiency and performance.
o	The size will be not only increasing but also decreasing; we can see this nature in ArrayList in briefly.
 	We collect/store different type and same type of objects in to one variable. That means we can store homogeneous and heterogeneous objects in our collection variable.
 	Collection having readymade/predefine methods for manipulate the objects.
 	Based on the requirement, we can store the duplication code and avoiding the duplication code or data redundancy.
 	All Collection classes are implements Cloneable, Seriablizable interfaces.
 	Both ArrayList and Vector classes implements RandomAccess interface also.
 	All Collection class override the toString() of Object class.
Collection:
•	Collection is a root interface for representing a group of objects nothing but elements as a single entity.
•	Collection doesn’t allow duplicates and some are allow duplicate values.
•	Collection are having order and some not having any order.
•	There is no direct implementation of this interface.

Collections:
Collections is an utility class available in java.util package for defining several utility methods for collection objects.
Types of Collection Framework:
Based on the way of strong the objects, the collection framework is categorized into two approaches.
(a)	Collection hierarchy.
(b)	Map hierarchy.
Collection hierarchy:
Mainly it has been classified into three categories.
(a)	List
(b)	Set
(c)	Queues
Map hierarchy:
In the map hierarchy in the objects will stored in the order of key-value pairs.
Collection interface:
 	Collection is a root interface.
 	It represents group of objects into single entity.
 	It is having common methods, which can be applied on any objects.
Methods in collection interface: 
List interface:
 	List is a child interface of Collection.
 	It is used for group of individual objects as single entity.
 	It can allow the duplicate values, null values and zeros (more than one time).
 	We can differentiate duplicate values by using index.
 	It is having an order of insertion by using index.
 	It has been included in java 1.2.
 	We can also call as sequence.
 
Methods in List Interface:
 

ArrayList Class:
 	It is the child class of List interface.
 	ArrayList is a growable and resizable array.
 	It allows the duplicate values.
 	Heterogeneous (different) objects are allowed.
 	Null insertion is possible.
 	Insertion order is preserved.
 	It is override the toString() method.
Constructors:
(1)	ArrayList l=new ArrayList();
Here capacity is empty/null.
The default initial capacity is ten (10).
(2)	If the ArrayList reaches its initial capacity, the new ArrayList will be created, with the (current capacity*3/2) +1.
Example:
The minimum capacity is 10. Then after the new capacity is
(10*3/2)+1=16.
(3)	ArrayList l=new ArrayList(int initial capacity);
(4)	ArrayList l=new ArrayList(Collection c)
Here ArrayList will create with the equality size of collection object.
Used at inter conversion between collection objects.



Methods in ArrayList:
 
 	ArrayList is implements Serializable and Clonable interfaces.
 	ArrayList implements the RandomAccess interface.
 	Then all the elements in the ArrayList can be retrieved with same speed.
 	That’s why ArrayList is best suitable for “fast retrieval”.
 	The drawback of the ArrayList is not suitable for frequent insertion and deletion operations at middle of ArrayList.
 	The reason is if we insert or delete the elements at middle of the array the shift operations will be happened, that why it will take more time. This is same for Vector class also.
Program on ArrayList:
import java.util.*;
class ArrayListDemo {
	public static void main(String args[]) throws Exception{
	System.out.println("good and bad morning");
	ArrayList l=new ArrayList();
	l.add("r");
	l.add("a");
	l.add("m");
	l.add("u");
	l.add("s");
	l.remove(4);
	System.out.println(l);
		}
}
Output:
 
import java.util.*;
class ArrayListDemo 
{
	public static void main(String[] args) 
	{
		System.out.println("Hello World!");
		ArrayList a=new ArrayList();
		a.add("A");
		a.add(".");
		a.add("ra");
		a.add("m");
		a.add(0,"F");
		a.add("A");
		a.add(null);
		System.out.println(a);
		System.out.println(a.size());
		System.out.println(a.isEmpty());
		System.out.println(a.contains("."));
		System.out.println(a.indexOf("ra"));
		System.out.println(a.lastIndexOf("ra"));
		Object o=a.clone();
		System.out.println(o);
		Object o1[]=a.toArray();
		System.out.println(o1[0]);
		System.out.println(o1[2]);
		System.out.println(o1[4]);
		System.out.println(o1[3]);
//		a.clear();
		System.out.println(a);
		System.out.println(a.get(5));
		System.out.println(a.remove(5));
		System.out.println(a);
		a.ensureCapacity(4);
		System.out.println(a.size());
		a.trimToSize();	
		System.out.println(a.size());
	}
}
//the default size is 10. and load factor is 3/2+1;
Output:
 
ArrayList is not suitable for frequent insertion and deletion at middle of ArrayList, and then to overcome this problem we have a new class called “LinkedList”.

LinkedList:
 	It is the child class of List interface, Deque, Queue.
 	LinkedList class extends AbstractSequentialList .
 	Duplicate objects will be allowed.
 	Null insertion can be allowed.
 	Insertion order will be preserved.
 	Heterogeneous object can be allowed.
 	It is the best suitable for frequent insertion and deletion operations at middle of the list.
 	Compare to ArrayList, the LinkedList will not be suitable for only frequent retrieval operation, why because it not implement the RandomAccess interface.
 	It is also implement the Serializable and Clonable interfaces.
 	Up to java1.4 the LinkedList only implements the List interface, whereas in java1.5 LinkedList is also implements the Queue interface.
Constructors in LinkedList:
LinkedList l=new LinkedList();
LinkedList l=new LinkedList(Collection c);
Methods in LinkedList: 
import java.util.*;
class LinkedListDemo 
{
	public static void main(String[] args) 
	{
		System.out.println("Hello World!");
		ArrayList al=new ArrayList();
		al.add("kiran");
		al.add("suji");
		al.add("vani");
		System.out.println(al);
		LinkedList ll=new LinkedList();
		ll.add("a");
		ll.add(10);
		ll.add(new Integer(100));
		ll.add(null);
		ll.add(2,"ramu");
		System.out.println(ll);
		ll.add(1,al);
		System.out.println(ll);
		ll.add(al);
		System.out.println(ll);
		ll.addFirst("first");
		ll.addLast("last");
		System.out.println(ll);
		Object o=ll.clone();
		System.out.println("clone values are:"+o);
		System.out.println(ll.contains("ramu"));
		System.out.println(ll.getFirst());
		System.out.println(ll.getLast());
		System.out.println(ll.get(5));
		System.out.println(ll.get(2));
		System.out.println(ll.indexOf("ramu"));
		System.out.println(ll.lastIndexOf("first"));
		System.out.println(ll.remove(5));
		System.out.println(ll.removeFirst());
		System.out.println(ll.removeLast());
		ll.set(0,100);
		System.out.println(ll);
		Object o1[]=ll.toArray();
		System.out.println(o1[1]);
		}
}


Output:
 
Vector class:
 	It is also child class of List interface.
 	It allows the duplicate values.
 	It is also allows the null values.
 	The order must be preserved.
 	It has been available from java1.0 onwards.
 	Like ArrayList, it is also best suitable for frequent retrieval operations, the reason it can be implements RandomAccess interface.
 	Like ArrayList, it is also not suitable for frequent insertion and deletion operations in the middle.
 	It is also implements the Clonable, Serializable interface.
 	It is somewhat similar to ArrayList but there are some difference between ArrayList and Vector.
 	Methods in ArrayList are not synchronized, whereas Vector methods are synchronized.
 	ArrayList is not thread safe, whereas Vector is a thread safe.
 	Performance is high in ArrayList, where as low in Vector.
 	ArrayList by default non-synchronized, where as Vector is synchronized.
 	We can get synchronized ArrayList by using following operation. That is
o	Public static List synchronizedList(ArrayList l);
Example:
ArrayList            l=new ArrayList();
List       l1= Collections.synchronizedList(l);














Methods in Vector:
 
Constructors in Vector:
(1)	Vector  v =new Vector()
Initial capacity is 10.
(2) Vector v=new Vector ();
The vector class size will be doubled after reached its max capacity.
(3)Vector v=new Vector (int initial capacity, int increment capacity);
(4)Vector v=new Vector (Collection c)
Stack:
It is the child class of vector.
 
Retrieving elements from Collections:
There are four ways to retrieve the element/objects from Collections objects.
They are:
(a)	For-each method.
(b)	Iterator.
(c)	ListIterator.
(d)	Enumeration.
The above b, c, d are all interfaces.
For-each loop:
It is a loop like for loop, which executes group of statements for each element of the collection.
Example:
For (variable: collection-object)
{
Statements;
}
Here collection-object having how many elements, that much of size will be assign into variable and that much of times statements will be executed.
Enumeration:
Enumeration is an interface, which is introduced in java 1.0.
It is useful for retrieving the elements from collection object.
Methods in Enumeration:
 
By using elements () method, we can get Enumeration object.
Elements() method will be available in Vector class in java.util package.
DrawBacks:
 	This Enumeration interface doesn’t have any remove method. It has only read only methods.
 	It is only applicable for Legacy class.
 	It is a single direction cursor.

Legacy class:
 	Legacy classes are those that were built using java 1.1 and java 1.2.
 	In general these classes are called as java classes.
 	In java 1.0, Vector class was available instead of dynamic array and since there were no ArrayList class people were forced to use Vector for this purpose.
 	When java 1.2 was released ArrayList was much more advanced to Vector but has all the features of Vector too.
 	So people started using ArrayList instead of Vector.
 	And in this case Vector became legacy class.
 	Legacy classes are introduced in 1.0 and re-engineered into java 1.2 versions.
Note:
But in general a “legacy” is a term used to define software created using older version of software.
Iterator:
 	Iterator is an interface, which was introduced in java 1.2.
 	It contains methods to retrieve the elements one by one from a collection object.
 	It has 4 methods.
 
 	It will work on any type of classes that is any Collection implemented class.
 	By using iterator () method of ArrayList also we can get Iterator object.
 	This method will available in List interface.
Drawbacks:
It is also single direction cursor.
It does not have operation like add and replace of new objects.
ListIterator:
 	ListItrator is an interface that contains methods to retrieve the elements one by one from a collection object, both in forward and reverse direction.
 	It has 9 methods.
 	 
 	It is the child interface of Iterator interface.
 	It is the bi-directional cursor.
 	It has additional feature when compare Iterator and enumeration, that is used for read, remove, replace, add the object.
Set Interface:
 	A Set interface represents a set of elements.
 	It doesn’t allow the duplicate elements.
 	There is no proper preserve of insertion.
Methods in Set: 
These methods same as Collection interface methods.
Set interface doesn’t contain any extra methods from Collection.
 


HashSet:
 	HashSet is a class, which represents set of elements (objects).
 	Insertion order is not preserved.
 	Duplication objects will not allowed.
 	Heterogeneous objects will be allowed.
 	Like List null insertion is possible, but only once.
 	It is based on hashCode of an object.
 	It is the best suitable for searching operation.
 	It is implements Serializable and Clonable interfaces.
 	It underlying data structure is HashTable.
 	The default inserting order is, if we insert first element there is no specific rule followed by JVM. After that inserting the second element, here JVM will compare the hashCode of first element to hashCode of second element.
 	If those two objects hashCode equal then, JVM will use the equals method on those two objects, if the return type true then, the JVM will decide to these two objects are duplicates, it place only one element in the HashSet.
 	If equals () method return false then JVM will place these two objects into HashSet.
 	If hashCode of the two objects are not equal in the first case, these two objects will place in HashSet.
 Methods in HashSet: 
Constructors in HashSet:
(1)	HashSet hs=new HashSet();
The default capacity is 16.
Load Factor is 0.75.
(2)	HashSet hs=new HashSet(int capacity)
(3)	HashSet hs=new HashSet(int initial capacity, float load factory);
Load factor must be in between 0 to 1.
(4)	HashSet  hs=new HashSet(collection c);
LinkedHashSet:
This is the sub class of HashSet.
It doesn’t have any additional methods. 
Features:
Introduced in java 1.4.
Underlying data structure is LinkedList + HashTable. That’s why it maintains the insertion order.
It doesn’t allow the duplicate values that are why it is best suited for cache memory application.
SortedSet:
SortedSet is a child interface of Set interface.
Its name specifies that, it will useful for grouping the unique object according to some sorting order.
The sorting order is may be default or customized sorting order.
Methods in SortedSet:
 
comparator():
This method will return Comparator interface.
If the sorting technique is default, then this method returns null.
TreeSet:
 	The underlying data structure is balanced tree.
 	Duplicate values are not allowed.
 	Insertion order is preserved.
 	Heterogeneous values are not allowed.
Constructors in TreeSet:
(1)	TreeSet ts=new TreeSet().
Creates an empty treeset object, where the sorting order is default natural sorting order.
The elements which are inserted into the set must implements Comparable interface.
(2)	TreeSet ts=new TreeSet(Comparator obj)
Creates empty TreeSet object, where sorting order is specific by Comparator.
This is customized sorting order.
(3)	TreeSet ts=new TreeSet(Collection c)
(4)	TreeSet ts=new TreeSet(SortedSet s)
 	Creates a new tree set containing the same elements and using the same ordering as the specified SortedSet.
 	For empty TreeSet as the first value null insertion is possible, but after inserting null value, if are trying insert any other null value then we will get NullPointerException.
 	Whereas non-empty, if we are inserting null value, then we will get NullPointerException.
 	If we want depend on natural sorting order, then we should place the homogeneous objects and comparable otherwise we will get ClassCastException.
 	If an object is a comparable, if and only if the corresponding class will implements Comparable interface.
 	String and all wrapper classes implemented Comparable interface.
 	Whereas StrinBuffer, StringBuilder does not implement the Comparable interface. 
NavigableSet:
For navigation of SortedSet purpose, the sun micro people introduce a new concept called NavigableSet.
It is the child interface of SortedSet interface.
It has some method for navigation purpose.



Methods in NavigableSet:
 
Comparable Interface:
It is available in java.lang package and contains only one method. That is
     Public abstract int compareTo(java.lang.Object obj);
Obj1.compareTo(obj2)
Rules:
(1)	Return positive number if obj1 comes before obj2.
(2)	Return negative number if obj1 comes after obj2.
(3)	Return zero, if obj1 and obj2 are equal.
When we inserted elements into TreeSet, if we are not using any sorting order, then we should call compareTo() method and default natural sorting order.
Comparator interface:
If we want inserted elements into TreeSet with our own or customized sorting technique then we should go for Comparator interface.
 This interface will be available in java.util package.
Methods in Comparator:
It has two methods.
 
(1)Public abstract in compare(obj1,obj2):
Rules:
(1)	Return positive number if obj1 comes before obj2.
(2)	Return negative number if obj1 comes after obj2.
(3)	Return zero, if obj1 and obj2 are equal.
(2)public abstract boolean equals(Obj);
 	If we using Comparator interface, we would provide implementation of compare(ob1,obj2).
 	Implementing equals() is optional, because it has implementation in Object class.
 	We can provide heterogeneous objects also.
Map Hierarchy:
Map hierarchy classes are used to collect elements in (key, value) pair of format.
Both key and value are objects only.


 
Map Interface:
 	Ina Map interface key should be unique, whereas value can be duplicate.
 	The pair of (key, value) is called one entry.
 	Map interface is not a child interface of Collection interface.
Methods in Map:
 
Entry Interface:
A map is a collection of entries (key, value), hence Entry is an inner interface defined in Map interface.
It has 5 methods.
 
HashMap class:
 	HashMap is a collection that stores elements in the form of key-value pairs.
 	If key is provided later, its corresponding value can be easily retrieved from the HashMap.
 	Keys should be unique.
 	Value may or may be duplicate.
 	The underlying data structure is Hashtable.
 	It not a synchronized, if multiple threads work on this object, we might be get unreliable values.
 	Insertion order is not preserved.
 	Heterogeneous object can be allowed.
 	It has been based on hashCode of the keys.
 	Null insertion can be possible for both key and values.
 	It has been introduced in java 1.2.
 	HashMap by default it is not a synchronized, but make it as synchronized(thread safe).
 	By using Collection.synchronziedMap(java.util.Map object) we make it as synchronized.




Methods in HashMap:
 
Constructors in HashMap:
(1) HashMap h = new HashMap()
Creates an empty HashMap object with default initial capacity is 16. Default fill ratio 0.75,like HashSet.
(2) HashMap h=new HashMap(int initial capacity)
(3)HashMap h=new HashMap(int initial capacity, float fillratio).
(4) HashMap h=new HashMap(Map m);
LinkedHashMap:
 	This is similar to HashMap.
 	The underlying data structure is HashTable+LinkedList.
 	Insertion order is preserved.
 	Introduced in java 1.2.
Methods in LinkedHashMap:
 
Hashtable:
 	Hashtable is similar to HashMap, which holds elements in the form of key-value pairs.
 	It is a synchronized class.
 	It is an thread safe.
 	Performance is low, when compare to HashMap.
 	Null value cannot be allowed in the place of key and value.
 	It has introduced in java 1.0.
 	The underlying data structure is Hashtable.
 	Insertion order is not preserved and it is based on hashCode of an objects.
 	Duplicate keys will not be allowed, but duplicate values can be allowed.
 	Heterogeneous objects will be allowed for both key and values.
Constructors in Hashtable:
(1)	Hashtable ht=new Hashtable();
Initial capacity is 11 and default fillratio 0.75.
(2)	Hashtable ht=new Hashtable(int initialcapacity);
(3)	Hashtable ht=new Hashtable(int initialcapacity, float fillratrio);
(4)	Hashtable ht=new Hashtable(map m);
IdentityHashMap:
In the case of duplication values in IdentityHashMap, the JVM will be uses the “==” operator for identifies the duplicates.
Where as in HashMap, the JVM will uses equals() method to identifies the duplicates.
WeakHashMap:
 	It is exactly similar to HashMap.
 	HashMap dominates GarbageCollector that is if any object associated with HashMap it is not eligible for Garbage Collector even though it doesn’t have external references.
 	But in the case of WeakedHashMap an object is eligible for Garbage Collector.
SortedMap interface:
It is child interface of the Map.
If we want represents all the entries according to default sorting order of keys, then we should go for SortedMap.


Methods in SortedMap:
 
Here Comparator compartor() method will return null if sorting order is not an default sorting order.
NavigableMap:
It the child interface of SortedMap.
It having some methods like below:
 

TreeMap:
 	TreeMap if follows the one datastructe is called as RED-BLACK tree.
 	Insertion order is not preserved but all the objects can be arranged according some sorting order of keys. Hence sorting order is preserved.
 	Duplicate values cannot allow for keys, but values can be duplicate.
 	If we use default sorting order, then the keys must be homogeneous and class must be implement Comparable interface, otherwise we will get a ClassCatException.
 	If we use customized sorting order, then the keys need not be homogenous (heterogeneous) and class must be implements Comparator interface.
Null acceptance:
 	For the empty TreeMap as the first element with null key is allowed, but after inserting null entry, we should not try to enter another null entries, if done we will get NullPointerException.
 	For Non-empty TreeMap, we should not try enter any null entries, if done, we will get NullPointerException.
 	There are no restrictions for values about null acceptance.
 	If we not provide any sorting order then by default sorting order will be used.
Constructors in TreeMap: 
(1)	TreeMap t=new TreeMap();
(2)	TreeMap t=new TreeMap(Comparator c);
(3)	TreeMap t=new Treemap(Map m);
(4)	TreeMap t=new TreeMap(SortedMap s);

Properties:
It is the chaild class of Hashtable class.
It can be used for representing key-values pairs.
Both key and values should be String objects.
Properties p =new Properties();
Methods in Properties class:
(1)	String getProperty(String name):
Returns the value associated with specified property.
If the specified property is not available, then it returns null values.
(2)	String setProperty(String name, String value);
(3)	Enumeration getPropertynames();
(4)	Void load(InputStream is)
To load the properties from properties file to java properties object.
(5)	Void store(OutputStream os, String comment);
To store the properties from java properties object to properties file.

 
Queue Interface:
 	If we want to represent a group of individual object prior to processing, then we should go for Queue interface.
 	Queue in general follows FIFO order, but we can implement our own order by using PriorityQueues.
 	LinkedList class is re-engineered in java5 version to implement Queue interface.
 	LinkedList based implementation of queue always follows FIFO.
 

Methods in Queue:
 
PriorityQueue:
 	If we want to store the objects prior to processing according to some priority, then we should go for PriorityQueue.
 	Insertion order is not preserved. But all the elements are arranged according to some priority. It may be default natural storing order or customized sorting order specified by Comparator object.
 	If your are depend upon the natural sorting, then elements should be homogeneous and comparable otherwise we will get ClassCastException.
 	If we are depended upon the our own sorting order then elements need be homogeneous and comparable.
 	Duplication objects are not allowed.
 	Null insertion is not possible even the first element itself.
Constructors in PriorityQueue:
(1)	PriorityQueue pq=new PriorityQueue();
Creates a default PriotyQueue, with the default size is 11 and all objects are sorted according some sorting order.
(2)	PriorityQueue pq=new PriorityQueue(int initialcapacity , comparatory c);
(3)	PriorityQueue pq=new PriorityQueue(SortingSet s);
(4)	PriorityQueue pq=new PriorityQueue(Collection c);
Collections:
Collections is a utility class, provides several utility methods for the collection implemented classes.
(A)	Sorting a List:
“Collections” class having a method to sorting a list i.e.,
Public static void sort (List L);
This method will sort the element of List by using some default sorting order.
If we use default sorting order, the elements must be homogeneous and comparable, otherwise we will get ClassCastException.
The List should not contain null values; otherwise we will get a NullPointerException.
Public void static sort (List l, comparator c)
This method will be useful for sorting the elements of List with some customized sorting order; here the elements need not homogeneous and comparable.
(2) Searching the List:
Public static int binarySearch(List l,Object key);
This method will be useful for searching the List elements with default searching order.
It is internally follows binarysearch algorithm.
Before using this method, the List elements should be sorted, otherwise we may get unreliable values.
The successful searching, this method will returns index value.
Otherwise it will show insertion place/index.
Insertion place/index is the place where we should enter some value to proper sorted.
Public static int binarySearch (List l, Object key, Comparator c);
This method will be useful for in the case of List is sorted by using Comparator.
We should pass the same Comparator object when we going to search the element from List.
Reversing the List elements:
Collection class contains one method for reversing the elements of List.
Public static void reverse (List l);

Arrays class:
Java.util package contain one utility class called Arrays.
This will provide some utility methods.
Sorting the elements of Array:
Following methods are helpful in sorting the Array elements.
Public static void sort(primitives[] p);
This method will sort the primitive elements of an array,
It will follow the default sorting order.
Public static void sort(Object[] o);
This method will sort the object type of elements of an Array..
It will maintain the default sorting order.

Public static void sort(Object[] o, comparator c);
To Sort the object Array according to customized sorting order.
Note:
The object Arrays will sort either customized sorting order or default sorting order, whereas primitive Arrays will sort only by natural/default sorting order only and not by customized sorting order.
Searching an Array: 
(a)	Public static int binarySearch(primitive[] p, primitive key);
(b)	Public static int binarySearch(Object[] o, Object key);
(c)	Public static int binarySearch(Object[] o, Object key, Comparator c);
Converting of Arrays as a List:
 	Arrays class contains one method to convert the Array in to List, i.e..
 	Public static List asList(Objective[] o);
 	This method won’t create a List object, the Array object will be given in the form of List object.
 	By using Array object, if we done any modification automatically it will reflect to List and same time if we done modification on List reference automatically it will reflect on Array object.
 	By using List reference if we are performing any operation which varies the size we will get runtime error saying: UnsupporttedOoperationException.



enum: 
	enum is to used grouping the named constants.
	With the help of enum we can develop user define 	datatypes.
	
	It has been introduced in java 1.5 version.
	
	Ex:
		enum Color{
			BLUE,GREEN,YELLOW;		
		}

	enum is always followed by enum_name.

	We can write empty enums also.
	Ex: 
		enum Color{
	  
	  	} 
	Naming conventions of enum same as class.
	
	Ex: 
		enum Month{
			jan,feb,march;
	      	}

	We can write the enum constants either in small 		letters or in capital letters.
	
	Constants may ended with the semicolon(;). It is 		not a mandatory.
	Ex: 
		enum Tifin{
			Idly,Dosa

		}
	If we want write any other content otherthan 			constants the constants must be ended with 		semicolon.
	Ex: 
	      enum Tifin{
		Idly,Dosa; //here ';' is mandatory.
		void m1(){
		}
	      }

	We cannot write abstract methods in constants.
		enum Tifin{
			Idly;
			//abstract void m1();
		}

	If we want to write any other content without 		constants in enum, before the content we should 		be place semicolon(;).
	Ex: 
		enum Tifin{
			; //mandatory
			void m1(){
			}
	      	}
	Within the enum we can write main method, we 		can compile and  execute the programs.
	
	Without class definition we can write the java 		code we can compile and execute.For this purpose 	we have two ways.
		1. with enum
		2. with interface
	
	1. with enum ( from java 1.5 onwards)
	
	enum Color{
			;
		public static void main(String args[]){
		  System.out.println("we can");
		}
	}
	
	2. with interface ( from java 1.8 )
		
	interface I{
		public static void main(String args[]){
	                     System.out.println("we can");
  	                }
	}
	
	We can write the enums outside of the class and 		inside of the class.
		
	If we are writing enum outside of the class, the 		bellow modifiers are allowed
	
	Ex: public, package-private (default), strictfp
	
	If we are writing enum inside of the class, the 			bellow modifersare allowed
	
	Ex: public,package-private(default), 			strictfp, private, protected, static,
	
	In above two conditions we can not write abstract 	keyword.
              	
	Every user define enum is by default subclass of 			java.lang.Enum.	
	
	We cannot write extends keyword after enum 	name, but we can write implements keyword.
	Ex: 
	enum Color extends Object{//wrong syntax
	}
	
	Ex: 
	enum Color implements Runnable{
		;
	      	public void run(){
		}
	}

	From java 1.5 onwards we can use enum 	constants value in the switch case also.
	
	"case" variables names must be equal or less than 	enum constants, and spelling must be equal		(including lower and upper case).

	We can not create object for enum.
	But we can create reference for enum.
	
	Ex: 
	enum Color{
		;
		public static void main(String[] ram){
		//Color c = new Color; //wrong syntax
		Color c;
		}	      
	}

	With the help of enum reference we can hold 	constant values.

	If we want read values from enum, we have one 		method like values().

	If we want know the positions of constants, then 	we have one method like ordinal().
	
	Ex: class A{
		enum Color{
			Blue,Yellow,Red;
		}
		public static void main(String... ram){
			Color c[] = Color.values();
			for(Color c1 : c){
		                   S.o.p(c1+"..."+c1.ordinal());
			}	
		}
	        }


package enums;
enum Color{
	BLUE,GREEN,YELLOW,red
}
enum Flower{
	;
	void m3(){
	}
}
/*enum A extends java.lang.Object{
} */
enum B implements java.lang.Runnable{
	;
	public void run(){
	}
}
public class EnumDemo {
	enum Month{
		Jan,Feb;
		void m1(){
		}
		//abstract void m2();
	}
	public static void main(String[] args) {
		//Color c = new Color;
		Color c[]= Color.values();
		for(Color c1: c){
			System.out.println(c1+"..."+c1.ordinal());
		}
	}

}


enum constants by default public static final.

enum with switch case:
enum Color{
	BLUE,GREEN,YELLOW,RED;

}
public class EnumDemo {
	public static void main(String[] args) {
		Color c = Color.YELLOW;
		switch(c){
		case BLUE: System.out.println("THIS IS BLUE COLOR");
				    break;
		case GREEN: System.out.println("THIS IS GREEN COLOR");
	    			break;
		case YELLOW: System.out.println("THIS IS  YELLOW COLOR");
	    			break;
	    /*case RED: System.out.println("THIS IS RED COLOR");
	    			break;*/
	    /*case PINK: System.out.println("THIS IS PINK COLOR");
					break;*/
	    default : System.out.println("NO COLOR MATCHED");
		}
	}
}
/*switch statement case values must same as enum constants.
we cannot use other than enum constant values.
but we can decrease the enum constants.*/	





Garbage Collection:
	In java we have two types of threads.
		1. Daemon Thread.
		2. Non-Daemon Thread.

	Thread: Executing group of statement in the separate path.

Non-Daemon Thread:
	these are high priority thread.
	These threads must be executed.
		Ex: main thread.
		
	All user define threads also come under Non-Daemon thread.
	Thre default value of Non-Daemon thread is '5'.
	
	If we want to check whether the thread is daemon or not,
	in java we one method that is " isDaemon()".

	If thread is Daemon then this method returns true.
	otherwise returns false.

	we can change our thread from non-daemon to daemon, with 	the help of one method i.e "setDeamon".

Deamon Thread: 
	These are low priority threads.
	We are not give gaurantee to execute.
	 	ex: Garbage collector.
	
	it is an one low priority thread.
	it is executed in the background by the jvm.

Why should we go for GarbageCollection?
	if we go to any other language like c++, if we want provide memory(allocating memory) our data programmer should write some code and also if we want to deallocating the memory in this time programmer should write some code. 
	if programmer forgot about deallocating memory code, some time later the memory will be filled, there may be chance of program is going to be stop .

	To avoid above drawback java introduced one predefine service or functionalaty i.e memory deallocation with the help of Garbagecollector thread.

	To cleanup the unused memory is called GarbageCollection.
	


public class Test {

		static void m1(){
			System.out.println("m1 method");
			Test t1 = new Test();
			Test t2 = new Test();
		}
	public static void main(String[] args) {

		Test t = new Test();
		Test t1 = new Test();
		Test t2 = new Test();
		//no object garbaged
		t1=null;
		//one object
		t=null;
		//two object
		t2= null;
		//three object 
		
		m1();
		System.out.println("*****");
	}

}
Communicating with GarbageCollector:
	In java we have two to communicate the garbage collector.
		
	1. System.gc();
	2. Runtime.getRuntime().gc();

GarbageCollector internally calls finalize() method to deallocate memory.
	
	public void finalize(){
	}

Another name of Garbage Collector is Finalizer.
Executing the finalize method and deallocating the memory is called finalization.



public class Test {

	public void finalize(){
		System.out.println(Thread.currentThread().getName()+" object garbaged");
	}
		
	public static void main(String[] args) {

		Test t = new Test();
		t=null;
		System.gc();
		
		Test t1 = new Test();
		t1.finalize();
		Test t2 = new Test();
		t2 = null;
		//Runtime rt = new Runtime();  //wrong
		Runtime rt1 = Runtime.getRuntime();
		rt1.gc();
		//System.gc();
	}

}

If we are calling finalize() explacitly like object.finalize(), in this time Garbage collector not execute finalize method, the respective thread will be execute the finalize().
so it is just method calling not finalization.

If finalize() internally calls by garbagecollector then only memory will be deallocated otherwise memory not deallocated.

if we are calling Stystem.gc() and Runtime.getRuntime().gc() repectively only one time memory will be garbaged.(not more than one time)

public class Test {

	int i = 111;
		
	public static void main(String[] args) {

		Test t1 = new Test();
		Test t2 = new Test();
		System.out.println("t1: "+t1.i);
		System.out.println("t2: "+t2.i);
		t2.i=333;
		t1=t2;
		System.out.println("t1 object is garbaged");
		System.out.println("t1: "+t1.i);
		System.out.println("t2: "+t2.i);
		t1.i=999;
		System.out.println("t1: "+t1.i);
		System.out.println("t2: "+t2.i);
		
	}

}

public class Test {
	int i = 111;
	static void m1(Test t1){
		Test t2 = new Test();
		Test t3 = new Test();
	}
	
	public static void main(String[] args) {
		Test t = new Test();
		System.out.println(t.i);
		m1(t);
		System.out.println(t.i);
	}

}
in the above program t2 and t3 memory will be deallocated and t1 reference will cancelled.

public class Test {
	
	public void finalize(){
	System.out.println(Thread.currentThread().getName()
				+" is called");
		int a = 10/0;
	}
	public static void main(String[] args) {
		Test t = new Test();
		//t.finalize();
		t = null;
		System.gc();
	}

}

When ever Finalizer(GarbageCollector) calls the finalize(), if any 
RuntimeExceptions are raised those are not thrown by finalize() that means unchecked exceptions are not thrown by finalize().
but if any thread call finalize() explacitly then finalize() will throws uncheckedexception messages.

Socket Programming:
Network: Interconnection between any two systems with in local or remote is called network.
Types of network:
1)	LAN
2)	MAN
3)	WAN
LAN: Stands for Local Area Network.
	The systems which are connected with in the organization level or building level is called LAN.
MAN: Stands for Metropolitan Area Network.
	The systems which are connected with in the city level are called MAN.
WAN: Stands for Wide Area Network.
	The systems which are connected throughout the world level are called WAN.
Request: The data (input) which is need to processing is called request.
Response: The data (output) which has processed is called response.
Client Program:  The program which is able to read the input values and send to another program is called client program.
Client Machine: The machine which has client program is called Client Machine.
Server program: The program which is able to send output values to client program is called server program.
Server Machine: The machine which has server program is called Server machine.
IP Address: Every system is identified in the network with one unique identification number that identification number is called IP Address. No two systems have same IP Address.
	IP Address starts with 0.0.0.0 to 255.255.255.255
Hostname:  The alternative of IP Address is called Hostname.
	We can identify the system either through IP Address or hostname.
Port: Every services running on unique number, that number is called port. No two services have same port number, if have those two services not running at a time.
Socket: It is a listener, which is used to send and read the request and response.
	Client side listener is called Socket.
	Server side listener is called ServlerSocket
Protocol:  It is a set of instructions. It is used to transform the data from client machine to server machine. 
	Types of protocols:
	TCP/IP: Transfer Control Protocol/Internet Protocol
	UDP: User Datagram protocol.
Under the TCP we have different sub protocols. They are
1)	http
2)	https
3)	smtp
4)	ftp
URL: Unified Resource Locator. It is used indentify the resource location. It is provide absolute path. 
Absolute path means combination of 
Protocol name + hostname/IP address + port number + resource + query string
URI: Unified Resource Identifier. It is directly represent the resource and query string.
	It provides relative path.
ClientDemo.java:
import java.io.BufferedReader;
import java.io.DataOutputStream;
import java.io.IOException;
import java.io.InputStreamReader;
import java.net.Socket;
import java.net.UnknownHostException;
public class ClientDemo {
	public static void main(String[] args) throws UnknownHostException, IOException {
		Socket s = new Socket("localhost",7777);
		DataOutputStream dos= new DataOutputStream(s.getOutputStream());
		BufferedReader br = new BufferedReader(new InputStreamReader (System.in));
		BufferedReader br1 = new BufferedReader(new InputStreamReader (s.getInputStream()));
		String str,str1;
		while(!(str=br.readLine()).equals("exit")){
			dos.writeBytes(str+"\n");
			str1=br1.readLine();
			System.out.println(str1);
		}
	}
}
ServerDemo.java
import java.io.BufferedReader;
import java.io.IOException;
import java.io.InputStreamReader;
import java.io.PrintStream;
import java.net.ServerSocket;
import java.net.Socket;


public class ServerDemo {
	public static void main(String[] args) throws IOException {
		ServerSocket ss = new ServerSocket(7777);
		Socket s=ss.accept();
		System.out.println("connection established");
		PrintStream ps = new PrintStream(s.getOutputStream());
	BufferedReader br = new BufferedReader(new InputStreamReader (System.in));
		BufferedReader br1 = new BufferedReader(new InputStreamReader (s.getInputStream()));
		String str,str1;
		while(true){
			while((str=br1.readLine())!=null){
				System.out.println(str);
				str1=br.readLine();
				ps.println(str1);
			}
		}
	}
}
Reflection API:
	If we want know source code information from ".class" file(byte code) then we can go for Reflection API.
	With reflection API we can read information  from runtime loaded class(.class).
	Reflection API provides mirror information about variables, methods, constructors, annotations, exception class information.
	With the help of reflection API we can access both private and public data.
	This Reflection API is coming under
 java.lang.reflect package.
	Important classes under java.lang.reflect packages are
	1)Filed
	2)Constructor
	3)Method
	4)Modifer
Filed: It is used to store the variable information. Variables may public or private.
Method: It is used to store the methods information (public or private)
Constructor: It is used to store the information about constructors.
Modifier: It is used to store information about access modifier and modifier.
 This class provides the modifier information in the form of int.
	If want convert from int to string then Modifier class itself provides some predefine method (toString()).
	ABSTRACT		1024
	FINAL			16
	INTERFACE		512
	NATIVE		256
	PRIVATE		2
	PROTECTED		4
	PUBLIC		1
	STATIC		8
	STRICT		2048
	SYNCHRONIZED	32
	TRANSIENT		128
	VOLATILE		64

java.lang.Class: This class having capability to hold bytecode information.
Important method under java.lang.Class:
	1)getDeclaredFields()
	2)getFields()
	3)getDeclaredMethods()
	4)getMethods()
	5)getDeclaredConstructors()
	6)getConstructors()

forName():
	It is an one static factory method, is used to loads the byte code of any class.
	forName() always needs bytecode not source code.
	
	Syntax :  Class cls = Class.forName("class_name");
	This method has been throwing one compile time exception i.e
	Java.lang.ClassNotFoundException.

newInstance(): 
	This is one instance factory methods, which is used to create object with the help of class reference variable.
	Object obj = cls.newInstance().
	newInstance() has been throwing two compile time excepitons.

	1) IllegalAccessException
	2) InstantiationException

import java.io.FileNotFoundException;
import java.io.IOException;
public class A {
	public int b=2000;  
	A(){      //getDeclatedConstructor or Constructor
		System.out.println("A class construc");
	}
	A(int x){
		System.out.println("A class paramconstruc");
	}
	private static int c =3000; 
	int m1()throws IOException,FileNotFoundException{
		return 10;
	}
	public void m2(int x){
		System.out.println("hi");
	}
}

import java.lang.reflect.Constructor;
import java.lang.reflect.Field;
import java.lang.reflect.Method;
import java.lang.reflect.Modifier;
public class B  extends A{
	public static void main(String[] args)
			throws ClassNotFoundException, InstantiationException, IllegalAccessException {
		java.lang.Class cls = java.lang.Class.forName("A");						java.lang.Object obj = cls.newInstance(); 
		Field f[]= cls.getDeclaredFields(); 
		for(Field f1:f){
			String modi = Modifier.toString(f1.getModifiers());
			if(modi.contains("private")){
				System.out.println(f1);
				f1.setAccessible(true);
				System.out.println(f1.get(obj));
				Object type = f1.getType();
				System.out.println(type);
			}
			
			System.out.println(f1);
		}
		System.out.println("*****************");
		Constructor[] c = cls.getDeclaredConstructors();
		for(Constructor c1:c){
			System.out.println(c1);
		}
		System.out.println("*****************");
		Method[] m = cls.getDeclaredMethods();
		for(Method a:m){
			System.out.println(a);
			System.out.println("*************");
			Class[] e = a.getExceptionTypes();
			for(Class e1:e){
				System.out.println(e1);				
			}
		} 
	}
}
